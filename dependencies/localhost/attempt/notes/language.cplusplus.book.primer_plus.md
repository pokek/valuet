---
id: 6a8esyepcbwvsqbze0kj2wl
title: Primer_plus
desc: ''
updated: 1666838073733
created: 1666794252866
---
## 第一章 预备知识

### 1、C++简介

C++融合了3种不同的编程方式：

- C语言代表的`过程性语言`
- C++在C语言基础上添加了类代表的`面向对象语言`
- C++模板支持的`泛型编程`

C++继承C语言高效、简洁、快速和可移植性的传统。

### 2、C++简史

#### 2.1 C语言编程：过程性语言

Bell实验室的Dennis Ritchie为了设计开发UNIX的通用性、可移植性等，在旧语言的基础上开发了C语言。

汇编语言依赖于计算机的内部机器语言，直接对硬件进行操作。

**数据**：程序使用和处理的信息。

**算法**：程序使用的方法。

C语言是 **`过程性语言`** ，强调编程的算法方面。一种结构化的编程方式。

C语言的新原则：**`自顶向下设计`**，理想：将大型程序`拆分`小型、便于管理的任务。

#### 2.2 面向对象编程

***`过程性语言（C语言）`强调`算法`，`OOP（C++、Java等）`强调`数据`*** 。

OOP不像过程性编程，其理念是设计与问题的本质特性相对应的数据格式。区别如下：

- `过程性语言（让问题来满足语言）`
- `OOP编程（让语言来满足问题）`

在C++中，类是一种`规范`，描述了`新型数据格式`，对象则根据类规范构造的`特定数据结构`。

类规定了可使用`哪些数据`来表示`对象`以及可以对这些`数据执行哪些操作`。

**OOP程序设计方法**：先设计`类（可以明确表示程序要处理的东西）`，然后设计使用`类的对象的程序`。

从`低级组织（如类）`到`高级组织（如程序）`的处理过程叫作 `自下而上` 的编程思想。

***`类定义 = 数据 + 方法`***

OOP可以创建可重用的代码，减少大量的工作，信息隐藏可以保护数据，使其免遭不适当的访问。

不同的环境（`Windows和Macintosh`）下提供编程的`类库`，可以方便地`重用`和修改现有的、经过仔细测试的代码。

#### 2.3  C++和泛型编程

泛型编程（generic programming）是C++支持的另一种编程模式。与OOP目标系统。

术语：`泛型（指创建独立于类型的代码）`。

**OOP与泛型编程的区别：**

- `OOP`强调编程的`数据`方面，是`管理大型项目`的工具
- `泛型编程`强调`独立于特定数据类型`，提供`执行常见任务（如对数据排序或合并链表）`的工具。

C++泛型编程需要对语言进行扩展，以便于可以`只编写一个泛型（即不是特定类型的）函数`，并将其`用于各种实际类型`。

### 3、可移植性和标准

C++是C语言的`超集`，任何有效的C程序都是有效的C++程序。

#### 3.1 可移植性的两个障碍

- **硬件**：分块放置模块，通过重写模块，最大限度降低可移植性问题。
- **语言上的差异性**：国际组织定义了C语言标准、定义了C++99、C++11、C++14等标准。

#### 3.2 C++的二重性

- OOP提供了高级抽象
- C提供了低级硬件访问

👉 C++既可以通过OOP进行抽象，也可完成类似C一样的对硬件访问的操作。

### 4、程序创建的技巧

#### 4.1 编程步骤

更多编译细节请阅读【编译原理】

![](/assets/images/2022-10-26-22-32-51.png)

#### 4.2 常见的编译器

- Linux/UNIX ： GNU gcc/g++
- Windows ：软件IDE
- Mac OS ： Xcode自带g++和clang

## 第二章 开始学习C++

### 1. 进入C++

```cpp
/*第一个C++程序*/

#include <iostream>
using namespace std; /*定义一个可视化*/

int main(void)
{
    cout<<"Come up an C++"<<endl;
    cout<<"You won't regret it"<<endl;

    return 0;
}
```

对于一个C++ 程序主要包含以下元素：

- 注释：由前缀`//` 或者是 `/* */` 标识
- 预处理器编译指令`#include`
- 函数头：`int main()`
- 编译指令：`using namespace`
- 函数体：用`{ }`括起来
- 使用C++ 的`cout`工具显示消息的语句
- 结束`main()`函数的`return`语句

#### 1.1、`main()`函数头

main() 被启动代码调用，而启动代码是编译器添加到程序中。
>函数头描述 `main()` 和OS（UNIX/Linux、Windows、mac os等）直接的`接口`。

`空括号的main()` 不接受任何参数。

```cpp
int main(void)
{
    statement
    return 0;
}
```

`main()`函数描述了函数的行为。同时也构成了两部分的 **`函数定义（function definition）`** ：第一行`int main()`函数叫做 **`函数头（function heading）`**，花括号({和})中包括的部分叫 **`函数体`**。

函数体：指出函数应做什么的计算机指令。

在C++中，每条完整的指令叫做`语句`。所有的语句都是以 `分号`结束。

![](/assets/images/2022-10-26-22-41-49.png)

`main()`中最后一条语句叫做 `返回语句（return statement）`，结束main()函数。

⚠️注意：C++程序通常是以`main()`函数开始执行，如果没有，程序不完整，则`编译器会指出未定义main()函数`。
> 大小写都必须准确
>
> 不需要`main()函数`的特殊情况：
>
> 1. Windows中的`动态链接（DLL）`模块。
> 2. 单片机或机器人芯片

#### 1.2、C++注释

C++中的注释以 **`双斜杠（//）`** 打头。以`行尾`作为结束。

**注释的作用**：为程序提供解释说明，使得程序通俗易懂。

通常标识程序的一部分或者是标识代码的某个方面。

**注意点**：编译器不会运行，会直接忽略注释。

C++也可以识别C语言的注释

C语言风格的注释

- **`多行注释`**：符号`/*`和 `*/` 之间，以 `*/` 作为注释的结束。
- **`单行注释`**：以 **`双斜杠（//）`** 开始，`行尾`作为结束。

#### 1.3、预处理器和头文件

如果程序要使用C++输入或输出工具时，必须使用两行代码：

```cpp
#include <iostream>
using namespace std;
```

使用了 `#include`作为了预编译指令，也就是所谓的预处理器指令。
> 预处理器的操作：在源代码被编译之前，替换或添加文本。

例如：

```cpp
#include <iostream>
```

像iostream这样的文件叫做 **`包含文件（include file）`** ———— 也被包含在其他的文件中，所以也叫做 **`头文件（header file）`**。

头文件命名约定
|头文件类型|约定|示例|说明|
|:--:|:--:|:--:|:--:|
|C++旧式风格|以 `.h` 结尾|iostream.h|C++程序可以使用|
|C旧式风格|以 `.h` 结尾|math.h|C、C++ 程序可以使用|
|C++ 新式风格|没有扩展名|iostream|C++程序可以使用，使用namespace std;|
|转换后的C|加上前缀c，没有扩展名|cmath|C++ 程序可以使用，可以使用不是C的特性，如namespace std;|

#### 1.4、名称空间（namespace）

如果程序中使用的是 `iostream` ，那么就需要使用名称空间编译指令来使得对程序可用。

```cpp
using namespace std;
```

也叫做 **using编译指令**。

#### 1.5、使用cout进行C++的输出

```cpp
    cout<<"Come up an C++"<<endl;
    cout<<"You won't regret it"<<endl;
```

`双引号` 括起来的部分就是要打印的消息。

在C++中，使用`双引号`括起来的一系列字符叫做 **`字符串`**，由于若干个字符组合而成。

`<<` 指出信息流动的路径，cout是一个`预定义的对象`。

![](/assets/images/2022-10-26-22-42-31.png)

##### 初识运算符重载

<< 既可以是插入运算符，也可以是左移运算符。
> 典型的运算符重载的情况，通过重载，同一个运算符代表不同的含义。具体含义编译器会通过上下文来确定。

常见的运算符重载例子

- `&` ----> 既表示地址运算符，又表示按位AND运算符。
- `*` ----> 既表示乘法，也表示对指针解除引用。

##### 控制符`endl`

```cpp
cout<<endl;
```

endl 是C++中的一个特殊符号，作用：**重起一行**。

在输出流中插入`endl`使得屏幕光标移到下一行开头。

endl在头文件`iostream`中定义，且位于`名称空间std`中。

##### 换行符

C++也也提供了早期C语言表示换行的方法；C语言符号`\n`。

`\n` 被视为一个字符，名为`换行符`，也就是C++中的`endl的重起一行`。

显示字符串时，在字符串中包含换行符，而不是在末尾添加endl，可减少输入量。

```cpp
/*两个语法都是一样的，都是：重起一行*/
cout<<"\n";
cout<<endl;
```

#### 1.6、C++源代码风格

C++中源代码的风格遵循以下规则：

- 每条语句各占一行。
- 每个函数都有一个`开始花括号`和一个`结束花括号`，两个花括号各占一行。
- 函数中的语句都相对于花括号进行缩进。
- 与函数名称相关的`圆括号周围没有空白`。

### 2. C++语句

程序代码例子：

```cpp
#include<iostream>
using namespace std;

int main()
{
    int carrots; // 声明一个整型变量

    carrots = 25; // 给变量赋值
    cout<<"我有 "<<carrots<<" 个carrots."<<endl;

    carrots = carrots - 1; // 对变量进行修改
    cout<<"快看！快看！现在，我有 "<<carrots<<" 个carrots!"<<endl;

    return 0;   
}
```

#### 2.1 声明语句和变量

在C++中，**`首次使用变量时，必须声明`** 。可以避免因拼写错误而难以发现错误。

声明通常指出要存储的数据类型和程序对存储在内存里的数据使用的名称。

程序中的声明语句叫作`定义声明`语句，简称`定义`。定义会使得编译器为`变量分配内存`。

⚠️注意：声明不一定是定义。

#### 2.2 赋值语句

赋值语句将值赋给存储单元。

符号 `=`叫作`赋值运算符`。👉 小Tips：C++中允许连续使用赋值运算符。

赋值是`从右向左`进行。

### 3. 其他C++语句

#### 3.1 cin 和cout

`cin` 使用 `>>` 运算符从`输入`流中抽取字符。
> 可以将通过键盘输入的一列字符（即输入）转换为接收信息的变量能够接受的形式。

`cout` 的对象属性包含一个插入运算符 `<<` ，将右侧的信息插入到输出流中。
> << 运算符可以进行多条输出语句的拼接。

#### 3.2 类的简介

类是C++ `面向对象编程（OOP）`的核心概念之一。

##### 什么是类？

类是用户定义的一种数据类型。

要定义类，需要描述它能够表示`什么信息`和`可对数据执行什么操作`。

类定义描述的是：`数据格式`及其`用法`，而`对象`则是根据`数据格式规范`创建的`实体`。

##### 两个类`cin类` 和 `cout类`

- `cin`类：`istream类对象`
- `cout`类：`ostream类对象`，`ostream类定义`描述了`ostream对象`表示的`数据`以及对它执行的`操作`。

> 两个类没有被内置到编译器中。
**注意点**：`类`描述了一种数据类型的`全部属性（包括使用它执行的操作）`，`对象`则是根据描述`创建的实体`。

##### C++中信息发送的方式

- 使用类方法（函数调用等）
- 重新定义运算符

### 4. 函数

两种C++函数

- 有返回值
- 无返回值

#### 4.1 有返回值的函数

有返回值的函数将生成一个值，而值将赋值给变量或其他的表达式中使用。

- **被调用函数**：被调用的函数
- **调用函数**：包含调用的函数
- **返回值**：发送回的值

**`参数`** 是发送给函数的信息， **`返回值`** 是从函数中发送回去的值。

👉 **小Tips**：对于C++编译器而言，`函数的参数类型`和`返回值类型`必须`一致` 。

⚠️注意：C++程序应当为程序中使用的每个函数提供原型。
> 函数原型结尾必须以 `分号(;)` 结束。如果省略分号，编译器则认为是`函数头`，要求提供定义该函数的函数体。

**~~不要混淆函数原型和函数定义~~**
> `函数原型`只描述`函数接口`。
>
> `函数定义`包含`函数的代码`。

👉 **小Tips**：`首次`使用函数之前`提供原型`，一般把原型放在 `main()函数定义`前面。

#### 4.2 函数变体

- 在原型中使用关键字void来指定返回类型，指出函数没有返回值。

    ```cpp
    void bucks(double);
    ```

- 关键字void不接受任何参数。如果省略void，让括号为空，则C++解释为一个不接受任何参数的隐式声明。

    ```cpp
    int rand(void);
    ```

#### 4.3 用户定义的函数

对于库函数，在使用之前必须提供其原型，通常把原型放在main()定义之前。

- 函数格式
函数格式为：`一个函数头 + 花括号的函数体`。

    ```cpp
    type functionname(arguementlist)
    {
        statements
    }
    ```

C++ ~~不允许将函数定义嵌套在另一个函数中~~，每个函数定义独立。

- 函数头
例如`main()`函数头。

⚠️注意：关键字是专用词，不能用作他用。
> return不能用作变量名，double不能用作函数名。

#### 4.4 用户定义的有返回值的函数

有返回值的函数，使用`关键字return`来提供返回值，并结束函数。

##### 函数的特性

- 有函数头和函数体
- 接受一个参数
- 返回一个值
- 需要一个原型

#### 4.5 在多函数程序中使用using编译指令

让程序访问名称空间std的4种方法

- 将 `using namespace std;` 放在`函数定义之前`，让文件种所有的函数都能够使用`名称空间std`中所有的元素。
- 将 `using namespace std;`  放在`特定的函数定义之前`，让该函数能够使用`名称空间std中`的所有元素。
- 在特定的函数中使用类似 `using std::cout`;编译命令，而不是 `using namespace std;` 让该函数能使用指定的元素，如cout。
- 完全不使用`编译指令using`，而在需要使用`名称空间std`中的元素是，使用前缀`std::`。

## 第三章 数据处理

### 1. 简单变量

程序必须记录3个基本属性

- 信息将存储在哪里
- 要存储什么值
- 存储何种类型的信息

#### 1.1 变量名

C++变量命名规则

- 变量名只能使用`字母字符`、`数字`和`下划线（_）`。
- 名称的`第一个`字符不能是`数字`。
- 区分大小写
- ~~不能将关键字用作名称~~
- 以`两个下划线`或`下划线`和`大写字母开头`的名称被保留给`实现（编译器及其使用的资源）`使用。以一个下划线开头的名称被保留给实现，用作`全局标识符`。
- 对名称长度没有限制，名称中所有字符都有意义。

✅ 小Tips:变量名建议使用 `驼峰式` 的格式。例如：myEyeTooth 或 my_eyes。

#### 1.2 整型

整数：没有小数部分的数字。如：77、-120等。

C++中，不同的整型使用不同的内存量，使用的内存越大，可表示的数值范围越大。

整型分为：

- 正值
- 负值

#### 1.3 整型short、int、long和long long

计算机内存的基本单元：**位（bit）** 。

**字节（byte）** 通常是8位的内存单元。字节指的是描述计算机计算机内存量的度量单位。

单位换算：

```cpp
1 KB = 1024 byte
1 MB = 1024 KB
```

在C++种也确保了类型的最小长度

- short 至少 16位
- int 至少和 short一样长
- long至少32位，且至少与int一样长
- long long 至少 64位，且至少与long一样长。

要知道系统中整数的最大长度，可以使用C++工具来检查类型的长度。

首先使用sizeof运算符返回类型或变量的长度，单位为字节。

climits中包含符号常量（预处理方式）来表示类型的限制。

```cpp
#include<iostream>
#include<climits> // 定义了符号常量来表示类型的限制
using namespace std;

int main()
{
    // 变量的初始化
    int n_int = INT_MAX;
    short n_short = SHRT_MAX;
    long n_long = LONG_MAX;
    long long n_llong = LONG_MAX;
    /**使用sizeof()运算符, 不是函数
     * 
     * 可对类型名（如int）或者是变量名（如n_short）使用，对变量名使用时，括号可有可无。
     */
    cout<<"int 是 "<<sizeof(int)<<" bytes "<<endl;
    cout<<"short 是 "<<sizeof n_short<<" bytes "<<endl;
    cout<<"long 是 "<<sizeof n_long<<" bytes "<<endl;
    cout<<"long long 是 "<<sizeof n_llong<<" bytes "<<endl;
    
    // 最大值
    cout<<"MAXIMUM Values:"<<endl;
    cout<<"int : "<<n_int<<endl;
    cout<<"short : "<<n_short<<endl;
    cout<<"long : "<<n_long<<endl;
    cout<<"long long : "<<n_llong<<endl;

    // 最小值
    cout<<"MINIMUM int value = "<<INT_MIN<<endl;
    cout<<"Bits per byte = "<<CHAR_BIT<<endl;

    return 0;
}

```

#### 1.4 变量初始化问题

- 初始化将赋值和声明合并在一起。也可以使用`字面值常量`来初始化。也可以直接使用`表达式`来初始化变量。

```cpp
int variable00 = value;
int variable01 = value1 + value2;
int variable02(4);
```

- 如果不对函数内部定义的变量进行初始化，该变量的值不确定的。

- 将大括号初始化用于单值变量。

```cpp
int emus{7};
int rheas{12};
int var = {12};
```

> 大括号初始化器可用于任何类型（可以使用等号，也可以不使用），属于通用的初始化语法。

- 在大括号内也不包含任何东西。此时变量初始化为零。

- 变量的初始化的问题，有助于防范类型转换错误。

#### 1.5 无符号类型

优点：可以增大变量能够存储的最大值。

创建无符号类型的变量时，只需要使用unsigned来进行声明即可。
> short变量加unsigned和没有unsigned，两者显示结果都是不一样的。

```cpp
unsigned int un_int = 100;
unsigned short u_sint = SHRT_MAX;
```

#### 1.6 整型字面值

整型字面值（常量）：显式书写的常量。如777或者是222。

C / C++中的三种计数方法：

- 十进制（第一位为1～9，基数为10）----> dec
- 八进制（第一位为0，基数为8） ----> oct
- 十六进制（前两位以0x或0X开头，基数为16，0～9和a～f（A～F）的组合）----> hex

> 默认情况下，cout以`十进制形式`显示整数。

#### 1.7 char类型：字符和小整数

char类型：专门存储`字符（如字母和数字）`，也是另外一种整型。

一般不超过128个字符，可以表示计算机系统中的所有基本符号 -----> 所有的字母、数字和标点符号等。

ASCII字符集中的字符用数值编码（ASCII码）进行表示。如字符A的编码为65。

```cpp
#include <iostream>
int main(void)
{
    char ch = 'M';
    std::cout <<"The ASCII code for "<< ch <<" is "<<int(ch)<<std::endl;
    std::cout.put(ch); /* . 句点被称为成员运算符*/
    std::cout << std::endl;
    return 0;
}
```

 > `成员函数cout.put()` ———— C++ OOP概念中的成员函数，成员函数归类所有，描述了操作数据的方法。

有些字符无法通过键盘输入到程序中，所以C++提供了特殊的表示方法 ----> `转义序列`。常见的如下

![](/assets/images/2022-10-26-22-47-39.png)

✅ 小Tips:在可使用数字转义序列或符号转义序列（如\0x8和\b）时，应使用符号序列。
> 数字表示与特定的编码方式（如ASCII码）相关，而符号表示适用于任何编码方式，其可读性也更强。

<u> 将转义序列作为字符常量时，使用单引号，如果放在字符串时，则使用双引号</u>

```cpp
cout << endl; /*使用endl重起一行*/
cout <<'\n'; /*字符串常量*/
cout <<"\n"; /*字符串*/
```

#### 1.8 Bool类型

来源于数学表示法。

C++将`非零值`表示为`true`，将`零`表示为`false`。

```cpp
bool is_ready = true;
```

### 2. const限定符

符号名称指出了常量表示的内容。

`const关键字`来修改变量声明和初始化。常量被初始化后，其值就被`固定`，编译器将`不允许再修改`该常量的值。

将名称的`首字母大写`，以便提醒是个常量，可便于阅读性增强。如果是变量名全大写，则使用 `#define` 。

创建常量的通用格式为：

```cpp
const type name = value;
```

例如：

```cpp
const int Months = 12; // 一年有12个月
```

如果在声明const常量时没有提供值，该常量的值将是不确定，且无法更改。

### 3. 浮点数

浮点数就是表示小数点部分的数字。计算机将值分为两部分存储，一部分表示值，另一部分则用于对值进行放大或缩小。

#### 3.1 为什么叫浮点数？

因为小数点可移动，所以称之为`“浮点数”`。

表示方法：

##### 第一种 使用常用的`标准小数点`表示法

```
3.14159
10.0
```

##### 第二种 表示浮点值的方法叫做`E表示法（科学计数法）`

例如：

```
3.45E6 3.45与10的6次方相乘，E6代表的是10的6次方。
```

E适合表示`非常大`和`非常小`的数。

![](/assets/images/2022-10-26-22-48-03.png)

E表示法确保数字以浮点格式存储，即使没有小数点。

指数为负数意味着除以10的乘方，而不是乘以10的乘方。

8.33E～4表示:8.33 / 10的4次方,也就是：0.000833

**技巧**：

- d.dddE+n ———— 将小数点向右边移动n位
- d.dddE-n ———— 将小数点向左边移动n位

#### 3.2 浮点数类型

根据可以表示的`有效数位`和`允许的指数最小范围`，可以分为3种浮点数类型：`float`、 `double`和`long double`。

#### 3.3 浮点常量

在书写浮点常量的时候，加 `后缀` ， 以便区分何种类型，从而确定可表示的数值范围。例如：

```cpp
3.14f // float类型
3.14L // 长浮点型long double
```

#### 3.4 浮点数优缺点

两个优点：

- 表示整数之间的值
- 有缩放因子

缺点：

浮点数运算的`速度`通常比`整数运算慢`，而且`精度`完全`降低`。

### 4. C++算术运算符

五种基本运算符进行基本的算术运算。

`加（+）、减（-）、乘（*）、除（/）、求模（%）`

运算符的优先级和数学中的优先级类似。

#### 4.1 除法运算符问题的总结

除法运算符（/）的行为取决于操作数的类型。

如果两个操作数都是整数，则C++将执行整数除法。把结果的小数部分丢弃，使最后的一个结果是一个整数。

如果其中有一个（或两个）操作数是浮点数，则小数部分将保留，结果为浮点数。

```cpp
#include<iostream>
using namespace std;

int main()
{
    // 如果编译器不接受self()中的ios_base,请使用ios。   
    cout.setf(ios_base::fixed,ios_base::floatfield);
    cout<<"整数消除： 10 / 5 = "<<10/5<<endl; /*输出结果：10 / 5 = 2*/
    cout<<"浮点数消除：10.0 / 5.0 = "<<10.0/5.0<<endl; /*输出结果：10.0 / 5.0 = 2.000000*/
    cout<<"浮点数消除：10.0 / 5 = "<<10.0/5<<endl; /*输出结果：10.0 / 5 = 2.000000*/
    cout<<"double常量：1.e7 / 9.0 = "<<1.e7 / 9.0<<endl; /*输出结果：1.e7 / 9.0 = 1111111.111111*/
    cout<<"浮点常量：1e7f / 9.0f = "<<1.e7f / 9.0f<<endl; /*输出结果：1e7f / 9.0f = 1111111.125000*/
    return 0;
}
```

运算符重载：使用相同的符号进行多种操作。

#### 4.2 求模运算符

求模（求余）：返回`整数除法`的余数。

与整数除法结合，适用于解决要求讲一个量分成的整数单元的问题

⚠️注意：~~`浮点数`没有求模运算~~。

#### 4.3 类型转换

类型转换的规则

- 将一种算术类型的值赋给另一种算术类型的变量时，C++对值转换为接收变量的类型。
- 表达式中包含不同的类型时，C++对值进行转换
- 将参数传递给函数时，由函数原型控制，C++对值进行转换

数值转换中存在的潜在问题

![](/assets/images/2022-10-26-22-48-22.png)

类型的强制转换

**强制转换本身不会修改变量本身，而是创建一个新的、指定类型的值**。

强制转换的通用格式如下：

```cpp
(typename) value //来源于C语言
typename (value) // C++
```

#### 4.4 C++11中的`auto`声明

在初始化声明中，如果使用`关键字auto` 时，而`不指定变量的类型`，编译器将把变量的类型设置成与初始值相同。

```cpp
auto n = 100; /*自动设置为int类型*/
auto x = 1.15; /*自动设置为double类型*/
```

## 第四章 复合类型

### 1. 数组概述

#### 1.1 数组的定义

数组（array）是一种数据格式，能够存储多个同类型的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。

数组声明的三个特点：

- 存储在每个元素中的值的类型
- 数组名
- 数组中的元素数

C++中可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。

例如：

```cpp
short days[24]; // 一天有24个小时
```

#### 1.2 数组的声明

声明数组的的一般语法格式为：

```cpp
// 数组类型 数组名字[数组的大小]
int score[4]; // 四个人的分数，整型数组
```

数组的大小是指定`元素的数目`，必须是`整型常数或const值`，也可以是常量表达式(8*sizeof(int))

#### 1.3 复合类型的数组

可以使用其他的类型来创建（C语言使用术语：`派生类型`）

数组的用途，可以单独访问数组元素，方法是：使用`下标`或`索引`对元素进行编号。`从0开始编号`。
> 编译器不会检查下标是否有效，所以要注意下标合法性，避免程序异常问题。
C++使用索引的方括号表示法来指定数组元素。

#### 1.4 数组的初始化规则

1.只有在定义数组时才能初始化，此后不能使用，也~~不能将一个数值赋给另一个数组~~。

2.初始化数组时，提供的值少于数组的元素数目。

3.如果只对数组的一部分进行初始化，则编译器把其他元素设置为0。

4.如果初始化为`{1}`而不是`{0}`，则第一个元素被设置为1，其他元素都被设置为0.

5.如果初始化数组方括号内`（[]）`为空，C++编译器将`计算元素个数`。 例如：short things[] = {1,3,5,7};

#### 1.5 C++11数组初始化方法

C++11将使用大括号的`初始化（列表初始化）`作为一种通用的初始化方式，可用于所有类型。

在C++中列表初始化就增加了一些功能：

- 初始化数组时，可省略`等号（=）`

```cpp
double earnings[4] {1.2e4,1.6e4,1.1e4,1.7e4};
```

- 可不在大括号内包含任何东西，这会将所元素都设置为零。

```cpp
unsigned int const[10] = {};

float balances[100] {};
```

- 列表初始化禁止缩窄转换。

```cpp
long num[] = {25,92,3.0}; // 浮点数转换为整型是缩窄操作
```

例子：

```cpp
#include<iostream>

using namespace std;

int main()
{
    // 创建一个名字为yams的数组，包含了3个元素，编号是0～2.
    int yams[3];
    yams[0] = 7;
    yams[1] = 8;
    yams[2] = 6;

    // 使用逗号分隔的值列表（初始化列表），然后用花括号括起来即可。
    // 列表中的空格是可选的，如果没有初始化函数中定义的数组，其元素值也是不确定。
    int yamcosts[3] = {1,2,3};

    cout<<"yams 数组是："<<yams[0]+yams[1]+yams[2]<<endl;
    cout<<"yams[1] = "<<yams[1]<<endl;
    int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];
    total = total + yams[2] * yamcosts[2];
    cout<<"total yam = "<<total<<endl;

    // sizeof运算符返回类型或数据对象的长度（单位为字节）。
    // 如果将sizeof运算符用于数组名，得到的是整个数组的字节数。
    // 如果sizeof用于数组元素，得到的是元素的长度（单位为字节）。
    cout<<"\n yams数组的大小 = "<<sizeof(yams)<<" Bytes.\n";
    cout<<"一个元素的大小 = "<<sizeof(yams[0])<<" Bytes.\n";

    return 0;
}
```

### 2. 字符串

字符串是存储在内存的连续字节中的一系列字符。

#### 2.1 C++处理字符串的两种方式

- C语言，常常被称为`C-风格字符串(C-style String)`
    > 以空字符（\0,ASCII码对应为0）来标记字符串的结尾。
- 基于String类库的方法

存储在`连续字节`中的一系列字符意味着可以将`字符串`存储在`char数组`中。其中每个字符都位于自己的数组元素中。

使用`引号`括起来的字符串，这种字符串叫 **`字符串常量（String constant）` 或 `字符串字面值（string literal）`**  。
>字符串常量（使用双引号）不能与字符常量（使用单引号）互换。

例如：

```cpp
char name[] = "Soler";
```

字符串`结尾的空字符`，`不用直接显式包括`，机器在键盘输入，将字符串读入到`char类型`中，会在结尾`自动加上空字符`。

⚠️注意：确定了存储字符串所需的最短数组时，不要忘记把`结尾的空字符`包括在内。

#### 2.2 字符串常量的拼接

方法：直接两个引号括起来的字符串合并为一个。任何两个由`空白（空格、制表符和换行符）`分隔的字符串常量都将自动拼接成一个。

```cpp
cout<<"My name is " "Soler HO.\n" 
```

#### 2.3 在数组中使用字符串

将字符串存储到数组的常用方法：

- 将数组初始化为字符串常量
- 将键盘或文件输入读入到数组中。

```cpp
#include <iostream>
#include <cstring> /*提供strlen()函数*/
using namespace std;

const int Size = 15;

int main()
{
    char name1[Size];
    char name2[Size] = "C++owboy";
    // 字符串的拼接
    cout<<"Howdy!I'm "<< name2;
    cout<<"!,What's your name?\n";
    cin>>name1;

    cout<<"Well, "<<name1<<",your name has : "<<strlen(name1)<<" letters and is stored!\n" ;
    cout<<"In an array of "<<sizeof(name1)<<" Bytes\n";
    cout<<"Your iniatial is "<<name1[0]<<".\n"; // name1数组中的第一个元素
    name2[3] = '\0';
    cout<<"Here are the first 3 characters of my name:"<<name2<<endl;

    return 0;
}
```

`strlen() 函数` 和 `sizeof()运算符`的区别

- `strlen()`函数
  - 返回的是`存储在数组中的字符串的长度`，而`~~不是数组本身的长度~~`。
  - strlen()只计算`可见的字符`，而~~不把空字符计算在内~~。

- `sizeof()` 运算符
  - 指出`变量`或`数据类型`的`字节大小`。
  - 可用于获取`类、结构、共用体和其他用户自定义数据类型`的大小。

#### 2.4 读取一行字符串的输入

解决没有逐行读取输入的缺陷。

istream中提供了面向行的类成员函数：`getline()` 和 `get()` 函数

##### 2.4.1 面向行的输入：`getline()`

使用通过回车键输入的换行符来确定输入结尾。使用 `cin.getline()` 。

函数有两个参数：

- 第一个参数：存储输入行的`数组名称`。
- 第二个参数：要读取的字符数（注意包含结尾的`空字符（\0）`）。

格式：

```cpp
cin.getline(name,ArSize);
```

##### 2.4.2 面向行的输入：`get()`

与`getline()` 函数类似，接受的`参数相同`，解释参数的方式也相同，并`读到行尾`。

区别：`get()` 读取并`丢弃`换行符，将其留在输入队列中。

格式：

```cpp
cin.get(name,ArSize);
```

get() 将两个类成员函数拼接（合并）：

```cpp
cin.get(name,ArSize).get();
```

⚠️注意：get() 函数读取空行后设置会失效，输入会被阻断。可用如下恢复：

```cpp
cin.clear();
```

混合输入数字和面向行的字符串会导致的问题：无法输入地址。
> 解决方法：直接使用get()进行读取之前丢弃换行符。

### 3. string类

`string类`位于名称空间`std`中，所以需要提供`using指令`或者是直接使用`std::string`进行引用。

要使用`string类`，必须在程序中包含`头文件string`中。

string类定义隐藏了字符串的数组性质。

#### 3.1 string对象的方式

使用string对象的方式和使用字符数组相同。

- `C-风格字符串`来初始化string对象中。
- 使用`cin来将键盘输入`存储到string对象中。
- 使用`cout`来显示string对象。
- 可以使用`数组表示方法`来访问存储在string1对象中的字符。

赋值 —— 不能将一个数组赋给另一个数组，但可以将一个string对象赋另一个string对象。

```cpp
char char01[20];                // 创建一个空列表
char char02[20] = "Jason";      // 创建一个初始化数组

string str01;                   // 创建一个空的string对象
string str02 = "Soler Ho";      // 创建一个初始化的string对象

char01 = char01;                // 不可执行，一个数组不能赋值给另一个数组
str01 = str02;                  // 可执行，可将一个string对象赋给另一个string对象。
```

#### 3.2 复制、拼接和附加

string类简化字符串合并操作。

- 利用`运算符 +`将两个string对象合并起来。

```cpp
string str01;                  
string str02 = "Soler Ho";

string = str01 + str02;
```

- 可以使用`运算符 +=`将字符串`附加`到string对象的`末尾`。

```cpp
string str01;                  
string str02 = "Soler Ho";

str01 += str02;
```

### 4. 结构简介

结构是`用户定义`的类型，而结构声明定义了类型的`数据属性`。

定义类型之后，就直接创建类型的变量。

结构比数组灵活，同一个结构中可以存储多种类型的数据。

#### 4.1 创建结构的步骤

- 定义结构描述 —— 描述并标记能够存储在结构中的各种数据类型

- 按描述创建结构变量（结构数据对象）。

#### 4.2 结构的定义

```cpp
struct(关键字) 类型名(标记成为新类型的名称)
{
    结构成员1;
    结构成员2;
    结构成员3;
};//(结束结构声明)
```

对于结构中的成员，使用`成员运算符（.）`来进行访问各个成员。

#### 4.3 结构的初始化（C++11）

- 与数组一样，列表的初始化用于结构，且`等号（=）可有可无`。

```cpp
infor Soler_infor {"Soler HO",55,168}; // 在C++11中，= 号可以省略
```

- 如果大括号内未包含任何东西，各个成员都将设置为零。

```cpp
infor Soler_infor {};
```

- 不允许缩窄转换

✅ 小Tips：C++允许在声明结构变量时省略关键字struct。

#### 4.4 成员赋值

***成员赋值（memberwise assignment）***：可以使用`赋值运算符（=）`将结构赋另一个同类型的结构。这样结构中的每个成员都将被设置为另一个结构中相应成员的值。即使成员是数组。这种方式就是`成员赋值`。

### 5. 共用体

共用体（union），也叫做`联合（union）`。一种 **`构造数据类型`** 。

**关键字：union**

联合（union）：将`不同类型的数据`在一起**共同占用同一段内存**

存储不同的数据类型，但只能同时存储其中的一种类型

示例：

```cpp
union sample
{
    int int_val;
    long long_val;
    double double_val;
};
```

#### 5.1 结构体和共用体的区别

- 结构可以`同时存储int、long和double`。
- 共用体`只能存储int、long和double`三种。
- 含义不同。
- 关键字不同
  - 结构体：struct
  - 共用体：union

#### 5.2 共用体的用途

- 当数据使用两种格式或更多格式（但不会同时使用）时，可以节省空间。
  - 嵌入式系统编程（如控制烤箱、MP3播放器），内存非常宝贵。
- 常用于操作系统数据结构或硬件数据结构。

#### 5.3 匿名共用体

匿名共用体（anonymous union）`没有名称`，其成员将成为位于`相同地址`处的变量。

### 6. 枚举

C++的enum工具提供了另一种创建`符号常量`的方式，可以代替const，允许定义新类型，但必须有严格限制。

使用enum的语法格式与结构的使用类似。

```cpp
enum color{red,orange,yellow,green,blue,voilet};
```

#### 6.1 设置枚举量的值

```cpp
enum week{Monday = 1,Tuesday = 2;Wednesday = 3;Thursday = 4};
```

指定的值必须是`整数`。也可以只显示定义其中一些`枚举量的值`。

如果第一个变量未初始化，默认为0。后面没有被初始化的枚举量的值将比其前面的枚举量大1。也可以创建多个值相同的枚举量。

```cpp
enum {zero,null = 0,numero_one,one = 1};
```

#### 6.2 枚举的取值范围

每个枚举都有取值范围的上限，通过强制类型转换，可以将取值范围中的任何整数值赋给枚举常量，即使这个值不是枚举值。

#### 6.3 取值范围的定义

- 找出上限，需要知道枚举量的最大值。
  - 找到大于最大值的，最小的2的幂，减去1，得到就是取值范围的上限。
- 计算下限，知道枚举量的最小值。
  - 如果不小于0，则取值范围的下限为0，否则，采用寻找上限方式相同的方式，但是要加上负号。

对于选择使用多少空间来存储枚举由`编译器`决定。

### 7. 指针和自由空间

对于地址显示结果是`十六进制表示法`，因为都是常常描述`内存的表示法`。

- 指针与C++基本原理
  > 面向对象编程和传统的过程性编程的区别，OOP强调的是运行阶段(而不是编译阶段)进行决策。

  - **运行阶段**：程序正在运行是，取决于不同的情况。
  - **编译阶段**：编译器将程序组合起来时。坚持原先设定的安排

指针用于存储值的地址。指针名表示的是地址。
> `*运算符`称为间接值或解除引用运算符，将其应用于指针，得到该地址处存储的值。

#### 7.1 声明和初始化指针

指针的声明必须指定`指向的数据的类型`。

```cpp
int *p_updates; 
```

> `*p_updates` 的类型是`int`，所以`*运算符`被用于`指针`，所以p_updates变量必须是指针。

运算符*两边的`空格`是可选的。

```cpp
int *ptr; /*该情况强调：*ptr是一个int类型的值。*/

int* ptr; /*该情况强调：int* 是一种类型，指向int的指针。*/
```

在C++中，`int*`是一种复合类型，是`指向int的指针`。

```cpp
double *tax_ptr;
```

#### 7.2 指针的危险

在C++创建指针时，计算机将分配用来`存储地址的内存`，但是<u>不会分配用来存储指针所指向的数据的内存</u>。

⚠️注意：一定要在对指针应用`解除引用运算符(*)`之前，将指针初始化为一个`确定`的、适当的`地址`。

#### 7.3 指针和数字

整数可以加减乘除等运算，而`指针`描述的是`位置`。

C++语言~~数字不能作为地址使用~~，如果要把数字当地址来使用，应通过`强制类型转换`将数字转换为适当的地址类型。

#### 7.4 使用`new分配`和`delete释放`内存

指针在`运行阶段` 分配未命名的内存以存储值。然后使用内存来访问内存。

C语言中，使用 **库函数malloc()**来分配内存。C++中使用 ———— new运算符。

##### 7.4.1 要注意使用delete进行内存的释放

需要内存时，直接使用new来请求，这是内存管理数据包的一个方面。

如果使用了`delete运算符`，使得在使用完内存后，能够将其`归还给内存池`，这是有效使用内存的关键。

使用delete时，后面要加上指向内存块的指针。

```cpp
int * ps = new int; // 使用new进行内存分配
 ...
delete ps; // 使用delete进行内存的释放
```

##### ⚠️注意点

1.使用delete释放ps的内存，但是~~不会删除指针ps本身~~。

2.只能用`delete`来释放使用`new分配的内存`，但是如果是`空的指针`使用delete是安全的。

**使用delete的关键**：用于`new分配的内存`。~~不是要使用于new的指针~~，而是用于`new的地址`。

❌警告：不能创建两个指向同一个内存块的指针。会增加错误地删除同一个内存块两次的可能性。

#### 7.5 使用new创建动态数组

C++中，创建动态数组，只需要将`数组的元素类型`和`元素数目`告诉new即可。必须在`类型名`后面加上`方括号`，其中包含了元素数目。

通用格式：

```cpp
Type_name *pointer_name = new Type_name[num_element];
//例子
int * psome =new int[10]; // 创建10个int元素的数组
```

new运算符会返回第一个元素的地址

如果使用完new分配的内存，使用delete进行内存的释放。

```cpp
delete [] psome; // 进行内存的释放
```

delete和指针直接的方括号告诉程序，应`释放整个数组`，不仅仅是指针指向的元素。

delete中的`方括号的有无`取决于使用`new时的方括号有无`。

对于指针数组的使用，直接可以按照普通数组的使用即可。

#### 7.6 使用new和delete时，要遵循的规则

- 不要使用delete来释放不是new分配的内存。
- 不要使用delete释放同一个内存块两次。
- 如果使用`new[]`为`数组`分配内存时，则应使用`delete[]`来释放。
- 如果使用new[]为一个`实体`分配内存，则应使用`delete（没有方括号）`来释放。
- 对空指针使用delete时很安全。

### 8. 指针、数组和指针算术

指针和数组基本等价的原因：`指针算术(pointer arithmetic)` 和`C++ 内部处理数组的方式`。
>
> - 对`整数变量` + 1，其`值`增加1
> - 对`指针变量` + 1，增加的量等于它`指向的类型的字节数`。
获取数组地址的两种方式

```cpp
double * pw = wages; // 数组名 = 地址 ;将pw声明为指向double类型的指针。然后将其初始化为wages - - - wages数组中第一个元素的地址。

short * ps = &wages[0]; // 使用地址操作；使用地址运算符来将ps指针初始化为stacks数组的第一个元素。
```

#### 8.1 指针问题小结

##### 8.1.1 声明指针

要声明指向特定类型的指针，语法格式：

```cpp
TypeName *pointerName;
// 例子
double * pn; // pn 指向一个double类型
char * ps;  // ps 指向一个char类型
```

##### 8.1.2 给指针赋值

将内存地址赋给指针。可以对变量名应用 `& 运算符`，来获得被变量名的`内存地址`，new运算符返回未命名的内存的地址。

示例：

```cpp
double * pn;  // pn 指向一个double类型
double * pa; // pa 指向一个double类型

char * pc; // pc 指向一个char类型
double bubble = 3.2; 

pn = &bubble; // 把bubble的地址赋值给 pn
pc = new char; // 新建char地址并分配给pc
```

##### 8.1.3 对指针解除引用

对指针解除引用意味着获得`指针指向的值`。

- 方法1：对指针应用解除`引用`或`间接值运算符(*)`来解除引用。

```cpp
cout<<*pn;
*pc = 's';
```

- 方法2：使用`数组表示法`。~~不可以对未初始化为适当地址的指针解除引用~~。

##### 8.1.4 数组名

多数情况下，C++将`数组名`视为数组的`第一个元素的地址`。

```cpp
int tacos[10]; // 此时的tacos同样也是&tacos[0]
```

##### 8.1.5 指针算术

C++中允许指针和整数`相加`。加1 的结果等于`原来的地址值`加上指向的对象占用的`总字节数`。

也可以将一个指针减去另一个指针，获得两个指针的差。得到一个整数，仅当两个指针指向同一个数组(也可以指向超出结尾的一个位置)时，这种情况会得到两个元素的间隔。

##### 8.1.6 数组的动态联编和静态联编

使用数组声明来创建数组时，将采用`静态联编`，即数组长度在`编译`时设置。

```cpp
int tacos[10] // 静态联编
```

使用`new[]运算符`创建数组时，将采用`动态联编(动态数组)`，即将在运行时为数组分配空间，其长度为运行时设置。
> 使用这类数组后，要使用`delete[]`释放所占用的内存。

##### 8.1.7 数组表示法和指针表示法

使用`方括号数组表示法`等同于对指针`解除引用`。

数组名和指针变量也是一样。所以对于指针和数组名，既可以使用`指针表示法`，也可以使用`数组表示法`。

```cpp
int * pt = new int [10];
*pt = 5;
pt[0] = 6;
pt[9] = 5;
int coats[10];
*(coats + 4) = 12;
```

#### 8.2 指针和字符串

数组名是`第一个元素地址`。

如果给cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。

在cout和多数C++表达式中，`char数组名`、`char指针`以及用引号括起来的`字符串常量`都被解释为`字符串第一个字符的地址`。

<u>~~不要使用字符串常量或未被初始化的指针来接收输入~~。</u>
> 在字符串读入程序时，应使用已分配的内存地址。该地址不是数组名，也可以使用new初始化过的指针。

`strcpy()`接受两个参数,第一个：`目标地址`，第二个：`要复制的字符串的地址`。
> 要确定目标空间有足够的空间来存储副本。

#### 8.3 使用new创建动态结构

对于在指定结构成员时，`句点运算符`和`箭头运算符`的选择时：

- 如果结构标识符是`结构名`，则使用`句点运算符（.）`。
- 如果标识符是`指向结构的指针`，则使用`箭头运算符（->）`。

把new用于结构的两个步骤

- 创建结构
  > 要创建结构，需要同时使用结构类型和new。
- 创建访问其成员。

#### 8.4 C++管理数据内存的方式

- 自动存储
在函数内部定义的常规变量使用自动存储空间，称为`自动变量`。
  > 只在特定函数被执行时存在。

自动变量时一个`局部变量`，作用域为包含它的`代码块`。通常存储在`栈`中，遵循`后进先出（LIFO）`。

- 静态存储
  - 变量称为静态的方式
    - 在函数外面定义
    - 在声明变量时使用关键字static。

  整个程序执行期间都存在的存储方式（存在于程序的`整个生命周期`）。

- 动态存储
内存池（自由存储空间或堆）用于静态变量和自动变量，且内存是分开的。

- 线程存储（C++11特性）

### 9. 数组替代品 --- 模板类

模板类`vector`和`array`是数组的替代品。

#### 9.1 模板类vector

模板类`vector`类似于`string`类，也是一种`动态数组`。

- `vector对象`包含在`vector头文件`中。
- vector包含在名称空间std中，使用`using编译指令`、`using声明`或`std::vector`。
- 模板使用不同的`语法`来指出它存储的`数据类型`。
- vector类使用不用的语法来指定`元素数`。

#### 9.2 模板类array（C++11）

位于名称空间`std`中，与数组一样，array对象的`长度固定`，也使用`栈（静态内存分配）`，而不是`自由存储区`。
> 头文件 array。

#### 9.3 数组、vector和array的区别

无论是数组、vector对象还是array对象，都可使用`标准数组表示法`来访问各个元素。

从`地址`可知，array对象和数组存储在相同的`内存区域（即栈）`中，vector对象存储在`自由存储区域或堆`中。

可以将一个array对象赋给另一个array对象，对于数组，必须`逐个`元素`复制`数据。

## 第五章 循环和关系表达式

### 1. for循环

for循环为执行重复的操作提供了循序渐进的过程。

for循环是`入口条件（entry-condition）`循环。

#### 1.1 for循环的组成部分

- 设置变量初始化
- 执行测试，查看循环是否继续进行。
- 执行循环操作
- 不断更新测试的值

#### 1.2 for循环的通用格式

```cpp
statement01
for (initialization;test-expression;update-expression)
    statement01;
statement03;
```

> 说明：test_expression 决定了程序是否执行， 这里的表达式也就是所谓的关系表达式，即两个数进行比较。

结构示意图：

![](/assets/images/2022-10-26-23-08-22.png)

C++中常用的方式：在for和括号之间加上一个空格，而省略函数名与括号之间的空格。

```cpp
for(int i = 6;i<=12;i++);
    printf("i = %d\n",i);
```

#### 1.3 `递增`运算符`(++)`和`递减`运算符`(--)`

- 递增/递减：增加/减少一个单位

- 前缀和后缀的区别
  - **前缀递增/递减**：表示`操作符（++/--）`位于变量或表达式的`前面`。
    > 先执行运算，再生成值。
  - **后缀递增/递减**：表示`操作符（++/--）`位于变量或表达式的`后面`。
    > 先生成值，在执行运算。

将递增 / 递减运算符用于指针时，把指针增加/减少其指向的数据类型占用的字节数。

```cpp
 double arr[5] = {2.3,7.5,3.7,6.5,7.8};
 double *pt = arr;
 ++pt;
```

- `前缀/后缀递增 / 递减`运算符的优先级
`前缀递增、前缀递减`和`解除引用运算符`的优先级`相同`，从`左往右`的方式进行结合。

`后缀递增和后缀递减`的优先级相同，但是比`前缀运算符`的优先级`高`，从`左往右`的方式进行结合。

#### 1.4 组合复制运算符

就是合并了算术运算符和赋值操作的运算符。

|操作符|作用（L为左操作数，R为右操作数）|
|:--:|:--:|
|+=|将`L+R`赋给L|
|-=|将`L-R`赋给L|
|*=|将`L*R`赋给L
|/=|将`L/R`赋给L|
|%=|将`L%R`赋给L|

#### 1.5 关系表达式

![](/assets/images/2022-10-26-23-10-51.png)

> ⚠️注意：`等于`运算符（==）和`赋值`运算符（=）两者不要混淆。
>
> 比较两个量是否`相等`时，而要使用 `==`。

#### 1.6 C-风格的字符串

`数组名`是数组的`地址`。用引号括起来的字符串常量也是其地址。

C-风格字符串库中的`strcmp()`函数来比较，函数接收两个字符串地址作为参数（参数可以是指针、字符串常量或字符数组名）。

如果字符串相同，函数返回 0；

如果第一个字符串按字母顺序排在第二个字符串`之前`，则`strcmp()`函数返回一个`负值`。

如果第一个字符串按字母顺序排在第二个字符串`之后`，则`strcmp()`函数返回一个`正值`。

### 2. while循环

while循环是`没有初始化` 和 `更新部分` 的for循环。只有`测试条件` 和 `循环体`。

#### 2.1 while循环的语法格式

```cpp
while(test-condition)
    loop-body
```

#### 2.2 while循环的结构图

![](/assets/images/2022-10-26-23-09-21.png)

### 3. do while循环

### 4. 循环与文本输入

### 5. 循环嵌套和二维数组

### 总结：设计循环的指导原则

- 指定循环终止的条件
- 在首次测试之前初始化条件
- 在条件被再次测试之前更新条件。

## 第六章 分支语句和逻辑运算符

## 第七章 函数 --- C++的编程模块

## 第八章 函数探幽

C++区别于C语言，提供了新特性：包括 **`内联函数、按引用传递变量、默认的参数值、函数重载（多态）以及模板函数`**。

### 1.内联函数

编译过程的目标是`可执行程序（由一组机器语言指令组成）`。运行程序时，操作系统将指令载入到计算机内存中，则每条指令都有其`特定的内存地址`。

内联函数的编译代码与其它程序代码内联，编译器就使用相应的函数代码替换函数调用。

#### 1.1 常规函数和内联函数

**常规函数**：调用使得程序调到另一个地址（函数的地址），并在函数结束时返回。

> 将程序流程转到独立的函数。

**内联函数**：程序无需跳到另一个位置处执行代码，再跳回来。

> 用内联函数的代码来替换函数调用。

#### 1.2 内联函数的优缺点

**优点**：运行速度比常规函数快。

**缺点**：占用内存大

#### 1.3 使用内联函数的要求

- 在函数 `声明前` 加上 关键字inline
- 在函数 `定义前` 加上 关键字inline
- 一般用法：省略原型，将整个定义（函数头和所有函数代码）放在本应提供原型的地方。
- ⚠️注意点：~~内联函数不能递归，末尾不加分号(;)~~

👉例子：square函数计算

```C++
#include<iostream>

inline double square(double x){return x*x;}

int main()
{
 using namespace std;
 double a,b;
 double c = 13.0;
 a = square(5.0);
 b = square(4.5 + 7.5);
 cout << "a = "<<a<<" , b = "<<b<<"\n"; // a =25 b = 144
 cout << "c = "<<c; //c = 13
 cout << ", c squared = "<<square(c++)<<"\n"; // c = 14*14=169
 cout << "Now c = "<<c<<"\n"; //c=14
 return 0;
}
```

✅ 内联函数和常规函数一样，都是按值来传递参数。

> 在将值传递给函数square之前，程序自动把传入值强制转换为double类型。

#### 1.4 内联和宏

inline是C++新增特性。

> 在C语言中使用`预处理器#define`来提供宏。————> 内联代码的原始实现。
>
> ```c
> #define SQUARE(x) x*x
> ```
>
> 此时不是通过传递参数实现，而是通过文本替换来实现。

**宏的缺点**：~~不能按值传递~~。

### 2. 引用变量

**引用**：已定义变量的别名。

**主要用途**：用作 `函数的形参`。通过引用变量用作参数，函数将使用原始数据，而不是使用副本。

#### 2.1 创建引用变量

C和C++中使用 `地址符（&）` 来指示变量的地址。用来声明引用。 <u>（符号重载）</u>

```c++
int rats;
int & rodents = rats; // &不是地址运算符，是类型标识符的一部分。
```

引用 <u>必须在声明引用时将其初始化</u>，而不是类似指针，先声明，再赋值。

> 引用更接近 const指针，<u>*必须在创建时进行初始化*</u>，变量关联后，就无法更改。

#### 2.2 引用用作函数参数

**引用传递**：当引用被用作`函数参数`时，使得函数中的变量名成为`调用程序中的变量的别名`。

> 允许被调用的函数能够`访问调用函数`中的变量。

**按值传递**：被调用函数使用调用程序的值的**拷贝**。

> C语言中改用按指针传递的方式避开按值传递的限制。

使用和访问原始数据的方法：按 **`引用传递`** 和 **`传递指针`**。

当左值引用参数是 const时，会生成临时变量的两种情况：
> 左值参数：可被引用的数据对象。

- 实参的类型正确，但不是左值。

- 实参的类型不正确，但可转换为正确的类型。

**尽可能使用const**

>- 使用const可以避免无意中修改数据的编程错误
>
>- 使用const使函数能够处理`const`和`非const实参` ，否则只能接受`非const数据`。
>
>- 使用`const引用`使函数能够正确生成并使用`临时变量`(如果`实参`和`引用参数`不匹配，c++将生成`临时变量`)。

C++11 引入 **`右值引用`**，可指向右值，使用 `&&` 来声明。

代码例子 👇

```cpp
#include<iostream>

using namespace std;

double cube(double a);
double refcube(const double &ra); // 使用const的目的：防止引用的参数被修改。

int main()
{
    double x = 3.0;
    cout<<x<<" 的立方为: "<<cube(x)<<endl;
    cout<<x<<" 的立方为："<<refcube(x)<<endl;
    return 0;
}
double cube(double a)
{
    return a*a*a;
}
double refcube(const double &ra)
{
    return ra*ra*ra;
}
```

⚠️注意：如果函数调用的参数不是左值或与相对应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给匿名变量，并让参数来引用该变量。

#### 2.3 结构引用

引用适合 **结构和类**（用户自定义类型，非基本的内置类型）。

**<u>引入引用的目的</u>**：用于用户自定义类型，而不是基本的内置类型。

使用 `结构引用参数`的方式 与`基本变量引用` 相同，只需在声明结构参数时使用 `引用运算符&` 即可。

代码例子 👇

```cpp
#include<iostream>
#include<string>

using namespace std;

/*创建结构*/
struct free_throws
{
    string name;
    int made;
    int attempts;
    float percent;
};

/*声明函数原型*/
void display(const free_throws & ft); 
void set_pc(free_throws & ft);
free_throws & accumulate(free_throws & target,const free_throws & source);

int main()
{
    /*对部分初始化，其余部分设置为0*/
    free_throws one = {"ifelsa branch",13,14};
    free_throws two = {"Andor Knott",10,16};
    free_throws three = {"Minnie Max",7,9};
    free_throws four = {"Whily Looper",5,9};
    free_throws five = {"Long Long",6,14};
    free_throws team = {"Throwgoods",0,0};

    /*不做初始化*/
    free_throws dup;

    set_pc(one); /*set_pc中的ft为引用，按值传递不可行*/
    display(one); /*使用const引用参数，可以使用按值传递结构，但是使用引用的好处：可以节省时间和内存*/
    accumulate(team,one); /*第一个参数：引用 ———— 可修改，第二个参数：const引用*/
    display(team);

    /*使用返回值作为参数*/
    display(accumulate(team,two));
    accumulate(accumulate(team,three),four);
    display(team);

    /*使用返回值进行赋值*/
    dup = accumulate(team,five); /*添加five的数据给dup*/
    cout<<"Displaying team:\n";
    display(team);
    cout<<"Displaying dup after assignment:\n";
    display(dup);
    set_pc(four);

    /*ill-advised assignment*/
    
    /*将five的数据添加到dup中，再使用four的内容覆盖dup的内容。返回类型是const，不可修改，所以赋值不合法。*/
    accumulate(dup,five) = four;   
    cout<<"Displaying dup after ill-advised assignment:\n";
    display(dup);
    return 0;
}

/*输出展示*/
void display(const free_throws & ft)
{
    cout<<"Name : "<<ft.name<<'\n';
    cout<<"Made : "<<ft.made<<'\t';
    cout<<"Attempts : "<<ft.attempts<<'\t';
    cout<<"Percent : "<<ft.percent<<'\n';
}

/*计算*/
void set_pc(free_throws & ft)
{
    if(ft.attempts!=0)
        ft.percent = 100.0f * float(ft.made)/float(ft.attempts);
    else
        ft.percent = 0;    
}

/**/
free_throws & accumulate(free_throws & target,const free_throws & source) /*const类型，所以不可修改*/ 
{
    target.attempts += source.attempts;
    target.made += source.made;
    set_pc(target);
    return target;
}
```

#### 2.4 返回引用时的注意事项

避免返回函数终止时不再存在的内存单元引用。原因：函数运行完毕后将不存在。

~~杜绝使用临时变量的引用~~

```cpp
const free_throws & clone2(free_throws &ft)
{
 free_throws newguy; 
 newguy = ft; // 拷贝
 return newguy; //返回拷贝引用，返回一个指向临时变量newguy的引用，函数执行完毕后则不存在。
}
```

> 解决方法：
>
> 1.返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，返回的引用也随之指向所使用的数据。
>
> 2.使用`new`来分配新的存储空间，使得返回指向该内存空间的指针。👉**小缺点**：会忘记使用 `delete` 来`释放内存`。

改进后：

```C++
const free_throws & clone(free_throws &ft)
{
 free_throws *pt; //使用指针指向结构，所以*pt可直接代表 free_throws这个结构
 *pt = ft; //拷贝信息
 return *pt; //返回
}
```

如果返回一个结构，而不是指向结构的引用，将整个结构复制到一个临时变量，再将临时变量拷贝。效率比其他传递方式高。

#### 2.5 对象、继承和引用

**继承**：将语言的特性从`一个类` *传递* 给`另一个类`。

**继承的特征**：派生来继承了基类的方法，基类引用可以指向派生类对象，而`无需进行强制类型转换`。
> `ostream`是基类
>
> `ofstream`是派生类

#### 2.6 何时使用引用参数

***使用引用参数的两个主要原因***

- 程序员能修改调用函数中的数据对象。
- 通过传递引用而不是整个数据对象，提高程序的运行速度。（当数据对象（结构和类对象）较大时很重要）

***对于 `使用传递的值` 而 `不作修改` 的函数***

- 数据对象`很小`，如`内置数据类型或小型结构`，**`按值传递`**；
- 数据对象是`数组`，则使用`指针`，因为这是唯一的选择，并将 **`指针声明为指向 const 的指针`**；
- 数据对象是`较大的结构`，则使用 `const 指针`或 `const 引用`，可以 ***节省复制结构所需的时间和空间***；
- 数据对象是`类对象`，则使用 `const 引用`。传递类对象参数的标准方式是 **`按引用传递`**。

***对于`修改调用函数中数据`的函数***

- 数据对象是`内置数据类型`，则使用`指针`；

- 数据对象是`数组`，则`只能`使用`指针`；

- 数据对象是`结构`，则使用`引用或指针`；

- 数据对象是`类对象`，则使用`引用`。

### 3. 默认参数

**定义**：指当函数调用中省略了实参时自动使用的一个值。

设置默认值的方法：通过函数原型将值赋给原型中的参数。例left() 原型：

```cpp
char *left(const char *str,int n = 1);
```

对于`带参数列表`的函数，必须`从右向左`添加默认值（要为某个参数设置默认值，必须为其右边的所有参数提供默认值）。

```cpp
int harpo(int n,int m = 4 , int j = 5); //VALID
int chico(int n ,int m = 6,int j); // INVALID
```

实参按 `从左向右` 的顺序依次被赋给相应的形参，而~~不能跳过任何参数~~。

```cpp
beeps = harpo(3, ,8); // 不允许
```

**👉 默认参数的好处**：*减少要定义的析构函数、方法以及方法重载的数量**。

⚠️注意：只有原型指定了默认值，函数定义与没有默认参数时完全相同。

```cpp
#include<iostream>
const int ArSize = 80;
char *left(const char * str,int n = 1);
int main()
{
    using namespace std;
    char sample[ArSize];
    cout <<"Enter a string : \n";
    cin.get(sample,ArSize);
    char * ps = left(sample,4);
    cout << ps << endl;
    delete [] ps;
    ps = left(sample);
    cout << ps << endl;
    delete [] ps;
    return 0;
}
char *left(const char *str,int n)
{
    if(n<0)
        n = 0;
    char *p = new char[n+1];
    int i;
    for(i = 0;i < n && str[i];i++)
        p[i] = str[i];
    while(i<=n)
        p[i++] = '\0';
    return p;
}
```

设置新字符串程度的方法：使用 `strlen()` 函数。

```cpp
int len = strlen(str);
n = (n < len)?n:len
char *p = new char[n+1];
```

- C程序倾向于运行速度快，代码简洁。
- C++追求可靠性。

### 4. 函数重载（polymorphism）

- `默认参数`可以使用不同数目的参数调用同一个函数。
- 术语`多态（polymorphism）` 指多种形式，函数多态允许函数使用多种形式。
- 术语`函数重载` 指可以有多个同名的函数，则对名称进行重载。

> `函数多态（函数重载）`可使用多个同名的函数。

函数重载的关键是`函数的参数列表` ---> 函数`特征标`。

C++允许定义`名称相同`的函数，条件是`特征标不同`。

编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。
> 匹配函数时，不区分`const` 和`非const变量`。

⚠️注意：真正让函数能够进行重载的是：**特征标**。

#### 4.1 左值引用和右值引用（自我扩展补充）

C++ 11 中新增特性 👇

更多关于右值引用细节请关注 [Chapter18 内容](../Chapter18/README.md)
或者如下链接文章

超级简单易懂的讲解文章参考  👉 「[腾讯技术过程 一文读懂C++右值引用和std::move
](https://zhuanlan.zhihu.com/p/335994370)」完整位置请移步，以下内容个人笔记原因，随意进行了缩减，请大佬团队高抬贵手不要发律师函告知抄袭。

区分`左值`和`右值`的方法：查看能否对其进行`取地址`操作。
> 可取地址，位于等号左边 ---> 左值
>
> 不可取地址，位于等号右边 ---> 右值

✅ 参考文章总结：有地址的变量就是左值，没有地址的字面值、临时值就是右值。

- **左值引用**
能指向左值，不能指向右值的就是左值引用。

```cpp
int a = 5;
int &ref_a = a; // 左值引用指向左值，编译通过
int &ref_a = 5; // 左值引用指向了右值，会编译失败
```

**引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。** 但const左值引用是可以指向右值

```cpp
const int &ref_a = 5;
```

> 原因：const左值引用不会修改指向值，因此可以指向右值。

- **右值引用**

**右值引用的标志是`&&`**。

右值引用专门为右值而生，**可以指向右值，不能指向左值**

```cpp
int &&ref_a_right = 5; // ok
 
int a = 5;
int &&ref_a_left = a; // 编译不过，右值引用不可以指向左值
 
ref_a_right = 6; // 右值引用的用途：可以修改右值
```

**被声明出来的左、右值引用都是左值。 因为被声明出的左右值引用是有地址的，也位于等号左边。**

#### 4.2 何时使用函数重载？

函数重载不可滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。

### 5. 函数模版

#### 5.1 重载的模板

`函数模板`是通用的`函数描述`，使用`泛型（可用具体的类型替换）`来定义函数。所以也叫做`通用编程`。

建立一个模板，关键字 `template` 和 `typename` 是必需，除非使用`关键字class`代替typename，必须使用 `尖括号<>`。

```cpp
template <typename T> /*C++98 标准时添加关键字 typename*/
template <class T> /*C++98之前使用class*/
```

✅ 小Tips：如果需要多个将`同一种算法`用于`不同类型的函数`，请使用`模板`。如果不考虑向后兼容的问题，并愿意键入较长的单词，则`声明类型参数`时，应使用关键字`typename`而不是`class`。

⚠️注意：函数模板不能缩短可执行程序。

✅ 模板重载和函数重载类似。

#### 5.2 模板的局限性

模板函数也会有一些无法处理的某些类型。

```cpp
template <class T> /*等于 template <typename T>*/
void f(T a,T b)
{
    a=b; /*如果T为数组时，假设不成立*/
    if(a > b) /*如果T为结构时，假设不成立*/
}
```

#### 5.3 显式具体化

当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。

C++98标准使用的方法

- 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及他们的重载版本。
- 显示具体化的原型和定义应以<u>`template<>打头`</u>，并通过`名称`来指出类型。
- `具体化` <u>优先于</u>`常规模板`，而`非模板函数`<u>优先于</u>`具体化`和`常规模板`。

显式具体化的格式：

```cpp
template <> void Swap<int>(int&,int&)
```

#### 5.4 实例化和具体化

在代码中包含函数模板本身并不会生成函数定义，只是一个用于生成函数定义的方案。

**隐式实例化**：编译器在使用模板事会为特定类型生成函数定义时，即可实现模板实例。

**显式实例化**：直接告知编译器创建特定的实例。

```cpp
/*语法：声明所需的类 ----> 用符号 <> 符号指示类型，并在声明前加上关键字template*/
template void Swap<int>(int,int); /*显式实例化*/
```

⚠️注意：`显式具体化`声明在关键字template后包含`<>`，而显式实例化没有。

❌警告：不要试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化，否则会出错。

***`隐式实例化`、`显式实例化`和`显式具体化`统称为`具体化`。***

#### 5.5 编译器选择使用哪个函数版本

**重载解析**：决定为函数调用使用哪一个函数定义的过程。

解析的过程

- 创建`候选函数列表`，包含`被调用函数名称`相同的所有函数
- 使用候选函数列表创建可执行函数列表，这些都是参数数目正确的函数，为此有一个`隐式转换序列`，其中包括实参类型和相应的形参类型完全匹配的情况。
- 确定是否有最佳可执行函数，如果有则调用，没有则报错

在实际场景下，只考虑特征标，不考虑返回类型。

## 第九章 内存模型和名称空间

### 1. 单独编译

C++鼓励将组件函数放在独立的文件中。可单独编译文件，然后将其链接成可执行的程序。
> C++编译器既编译程序，也管理链接器。

C++都将一些结构声明或结构函数原型都放在头文件中，然后使用 `#include` 指令来管理头文件。（⚠️注意：不是包含源代码文件）

~~不要将函数定义或变量声明放到头文件中，简单场景无问题，大型场景会引发问题~~ 。

头文件中包含的内容

- 函数原型
- 使用`#define`或`const`定义的符号常量
- 结构声明
- 类声明
- 模板声明
- 内联函数

在同一个文件中只能将同一个头文件包含一次。例如，可能使用包含了另外一个头文件的头文件，为了避免这种情况，可以采用以下一种技术`#ifndef #define…..#endif`。

### 2. 存储持续性、作用域和链接性

C++中使用了四种不同的方案来存储数据，它们的区别在于`数据保留在内存中的时间`。

#### 2.1 作用域和链接

作用域描述了名称在文件的多大范围可见。

链接性描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。

C++变量的作用域的种类

- 局部的变量只在定义它的代码块使用（函数体）
- 全局（文件作用域）的变量在定义位置到文件结尾直接都可用。
- 自动变量的作用域为局部。
- 静态变量的作用域取决于如何被定义。
- 函数原型中的名称只在包含参数列表的括号内可用
- 类中声明的成员的作用域为整个类。
- 名称空间中声明的变量作用域为整个名称空间。

#### 2.2 自动存储持续性

在`函数定义中`声明的变量（包括函数参数）的存储持续性为`自动`的。程序执行其`所属的函数`或`代码块`时被创建，在执行完后被释放。**自动变量的名称没有链接性，因为不能共享**。
> 作用域为局部，没有链接性。

#### 2.3 静态存储持续性

在`函数定义外`定义的变量和使用`关键字static`定义的变量的存储持续性为`静态`，它们在程序整个运行过程中都存在.

提供了3种链接性：

- `外部链接性`：代码块的外面声明
  - 单定义规则：变量只能有一次定义。
  - C++提供了两种变量声明：
    - 定义声明：给变量分配存储空间。
    - 引用声明：不给变量分配存储空间（引用已有的变量）。引用声明使用`关键字extern`，且不进行初始化。
  - 如果多个文件中要使用外部变量，只需一个文件中包含该变量的定义（单定义规则），使用该变量的其他文件中，都必须使用关键字extern 声明。

- `内部链接性`：在代码块的外面声明，且使用static限定符。
  - 在其所属的文件中使用。
- `无链接性`：代码块内使用，且使用static限定符。
  - 一般是在函数内使用，尽管函数之间多次被调用，其值不会发生变化。

> 所有静态持续变量在整个程序执行期间都存在。

![](/assets/images/2022-10-26-23-28-28.png)

除默认的`零初始化`外，可对静态变量进行`常量表达式初始化`和`动态初始化`。

#### 2.4 线程存储持续性（C++11特性）

在多核处理器中，这些CPU可以同时处理多个执行任务，这让程序能够将计算机放在可并行处理的不同线程中，如果变量是使用`关键字thread_local声明`的，则其生命周期与所属的线程一样长。

#### 2.5 动态存储持续性

用`new运算符`分配的`内存一直存在`，直到使用`delete`运算符将其`释放`或程序结束为止，这种内存有时被称为自由存储或堆。

#### 2.6 说明符和限定符

存储说明符

- `auto（C++11中不是说明符）`：用于自动类型推断
- `register`：声明中指示寄存器存储，C++11中显式指出变量是自动。
- `static`：内部链接性，作用域为整个文件的声明中。主要使用静态局部变量。
- `extern`：引用声明，声明引用在其它地方定义的变量。
- thread_local（C++11新增）：指出变量的持续性与其所属线程的持续性相同。
- mutable：即使结构（或类）变量为const，其某个成员也可以被修改。
- `volatile`：程序代码没有对内存单元进行修改，其值可能发生变化。

#### 2.7 存储方案和动态分配

使用C++运算符`new（或C函数malloc()）`分配的内存，称为`动态内存`。
> 动态内存由`new` 和 `delete` 控制。而不是作用域和链接性规则控制。

编译器的三块独立内存：`静态变量、自动变量、动态存储`。

- 使用new运算符初始化
如果为内置的标量类型分配存储空间并初始化，可在类型名后面加上初始值，将其用括号括起。

```cpp
int *pi = new int (6);
```

要初始化常规结构或数组，需要使用大括号的列表初始化。

- new失败时
早期返回空指针，现在会触发异常std::bad_alloc。

- new和delete
运算符new和new[]分别调用如下函数：

```cpp
void * operater new(std::size_t);
void * operater new[](std::size_t);
```

称为分配函数，对应的释放函数如下：

```cpp
void operator delete(void *);
void operator delete[](void *);
```

- 定位new 运算符

new的两个功能：

1. 在堆中找到足以满足的内存块。
2. 指定要使用的位置（定位特性）。
    > 使用new定位特性，需要包含 `头文件new`。

### 3. 名称空间

在C++中，名称可以是`变量、函数、结构、枚举、类以及类和结构的成员`。

解决名称空间冲突的问题。

#### 3.1 传统的C++名称空间

**声明区域**：声明所在区域。

**潜在作用域**：变量的潜在作用域从`声明点`开始，到其声明区域的`结尾`。

#### 3.2 新的名称空间特性

通过定义一个新的声明区域来创建命名的名称空间 ---- 目的：提供一个声明名称的区域。避免名称空间中的名称之间发生冲突。

默认情况下，名称空间中的声明的名称是外部链接。
> 名称空间可以是全局，也可是另一个名称空间，但不能是位于代码块中。

##### 3.2.1 访问名称空间中的方法

- 通过`作用域解析运算符::`，使用名称空间来限定使用。
- C++机制（`using声明`和`using编译指令`）来简化对于名称空间中的名称使用。
  - using声明：仅名称空间中的特定的名称可用，通过作用域解析运算符进行。
  - using编译指令：使整个名称空间中的名称可用。

```cpp
using std::cout;
```

一般情况下，使用`using声明`比使用`using编译指令`更安全。

利用`namespace`来创建声明区域，用`using`关键字来使用。

### 4. 名称空间的一些指导原则

- 使用在已命名的名称空间中声明的变量，而不是使用`外部全局变量`或`静态全局变量`。
- 如果开发了一个`函数库`或`类库`；将其放在一个名称空间中。事实上，C++当前提倡将标准函数库
放在名称空间std中，这种做法扩展到了来自C语言中的函数。例如，`头文件math.h` 是与C语言
兼容的，没有使用名称空间，但`C++头文件cmath`应将各种数学库函数放在名称空间std中。实
际上，并非所有的编译器都完成了这种过渡。
- 仅将`编译指令using`作为一种将旧代码转换为使用名称空间的权宜之计。
- ~~不要在头文件中使用using编译指令~~。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用`编译指令using`,应将其放在所有`预处理器编译指令#include`之后

- 导入名称时，首选使用`作用域解析运算符`或`using声明`的方法。
- 对于`using声明`，首选将其`作用域`设置为`局部`而~~不是全局~~。

## 第十章 对象和类

### 0. OOP的特性

面向对象编程（OOP）的特性：

- 抽象
- 封装和数据隐藏
- 多态
- 继承
- 代码的可重用性

### 1. 过程性和面向对象两种编程的区别

- 过程性编程
首先要考虑遵循的步骤，然后考虑如何表示这些数据（不需要程序一直运行。将数据存储到一个文件中，然后从文件中读取数据）。

- OOP编程
优先考虑数据（需要考虑如何表示数据，还要考虑如何使用数据）

### 2. 抽象和类

抽象和简化是处理复杂性问题的方法之一。

抽象是通往用户定义数据类型的捷径，在C++中，用户定义类型指的是 **`实现抽象接口的类设计`**。

#### 2.1 类型是什么？

指定基本类型的三项工作：

- 决定数据对象需要的内存数量。
- 决定如何解释内存中的位
- 决定可使用数据对象执行的操作或方法

对内置类型有关的操作信息被内置到编译器中，而在C++中用户自定义的类型，则必须自己提供类型信息。

#### 2.2 C++中的类

类是一种将抽象转换为用户定义类型的C++工具。将数据表示和操作数据的方法组合成一个包。

一般来说，类规范由两个部分组成：

- 类声明：提供类的蓝图
    > 以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口。

- 类方法定义：提供细节
    > 描述如何实现类成员函数。

接口是一个共享框架，供两个系统交互时使用。

对于类（公共接口）的public 是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法组成。

***`要使用某个类，必须了解其公共接口；要编写类，必须创建其公共接口`***。

🚩 小Tips：C++程序员将`接口（类定义）`放在`头文件`中，将`实现（类方法的代码）`放在`源代码文件`中。

##### 2.2.1 类的定义

![](/assets/images/2022-10-26-23-35-49.png)

👉 说明：不必在类声明中使用关键字 private，因为这是类对象的默认访问控制。

类设计尽可能将共有接口与实现细节分开。

- 公有接口表示设计的抽象组件。
  - 将实现细节`放在一起`并将其与抽象分开称为`封装`。
- 数据隐藏（将数据放在类的私有部分中）是一种封装。
  - 将实现的细节`隐藏在私有部分`中。
  - 优点：防止直接访问数据，让使用类的用户无需了解数据如何表示。

对于C++程序而言，一般使用类来实现类描述，将结构限制为只表示纯粹的数据对象。

无论类成员是数据成员还是成员函数，都可以在类的公有部分或私有部分中声明使用。但由于隐藏数据是OOP的目标之一，所以数据项一般放在私有部分，组成类接口的成员函数放在公有部分，否则无法从程序中调用这些函数。

#### 2.3 实现类成员函数

创建类描述的第二部分：类声明中的原型表示的成员函数提供代码。成员函数与常规函数类似，但有特殊的特征：

- 定义成员函数时，使用`作用域解析运算符（::）`来标识函数所属的类。例如

    ```cpp
    void  Stock::update(double price);
    ```

- 类方法可访问类的private组件。

作用域解析运算符确定了方法定义对应的类的身份。
> 类中的其它成员函数互相使用彼此，不需要解析操作符，而在类声明和方法定义之外使用时，则需要使用。

定义位于`类声明中的函数`都将自动称为`内联函数`，类声明通常将短小的成员函数作为内联函数。也可在`类声明之外`定义成员函数，通过在`类实现部分中定义函数时`使用`inline限定符`使其成为内联函数。
> 内联函数一般也放在头文件中。

```cpp
class Stock
{
    private：
        ...
        void set_tot(); // 类声明内定义，但会转换为内联函数
    public：
        ...
};

inline void Stock::set_tot() //直接使用inline限定符将其变为它是类Stock的成员函数
{
    total_val = shares * shares_val;
}
```

要使用新类型，最关键是需要了解成员函数的功能，而不必考虑其实现细节。

#### 2.4 小结

指定类设计的两个步骤：

- 提供类声明
  - 声明私有部分：声明的成员只能通过成员函数进行访问。
  - 声明公有部分：声明的成员可被使用类对象的程序直接访问。
    > 通常，数据成员放在私有部分，而成员函数放在公有部分。
- 实现类成员函数
    _ 在类声明中提供完整的函数定义、而不是函数原型。

### 3. 类的构造函数和析构函数

一般来说，最好在创建对象时对其自动进行初始化。

```cpp
Stock gift;
gift.buy(10,24.75);
```

C++提供一种特殊的成员函数 ------> **`类构造函数`**：专门用于构造新对象、将值赋给对应的数据成员。
> C++为成员函数提供名称和使用语法，而程序员需要提供方法定义。

⚠️注意：构造函数没有声明类型。

#### 3.1 构造函数

C++使用构造函数来初始化对象的两种方式：

- 显式调用构造函数

    ```cpp
    Stock food = Stock("Tencent",20,450);
    ```

- 隐式调用构造函数

    ```cpp
    Stock garment("Furry Mason",50,2.5);
    // 与下面的显式调用等价
    Stock garment = Stock("Furry Mason",50,2.5);
    ```

每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数。

`构造函数被用来创建对象，而不能通过对象来调用`。

默认构造函数时在未提供显式初始值时，用来创建对象的构造函数。例如：

```cpp
Stock fluffy_the_cat; //默认构造函数
```

如果没有提供任何构造函数，则C++将自动提供默认构造函数（隐式版本吗，不做任何工作）。

默认构造函数没有参数，因为声明中不包含值。当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。
> 如果要创建对象，而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。

定义默认构造函数的方式有两种

- 给已有构造函数的所有参数提供默认值

    ```cpp
    Stock(const std::string & co = "Error",int n = 0,double pr = 0.0);
    ```

- 通过函数重载来定义另一个构造函数 ---- 一个没有参数的构造函数

    ```cpp
    Stock();
    ```

由于只能有一种默认构造函数，所以不能同时采用这两种方式。

程序例子code -----> 「[Stock00](./stock00)」

#### 3.2 析构函数

用析构函数创建对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序会自动调用一个特殊的成员函数 ---- **`析构函数`**。
> 析构函数主要是完成清理工作。只需要让编译器生成一个什么都不做的隐式析构函数即可。

析构函数`没有参数`，在类名前加上`～`，所以其原型如下：

```cpp
~Stock();
```

析构函数不承担任何重要的工作，所以将它编写为不执行任何操作的函数。

```cpp
Stock::~Stock()
{
    cout<< "Bye, " << company << "\n";
}
```

析构函数的调用

- `静态存储类对象`：在程序`结束时`自动被调用。
- `自动存储类对象`：在程序`执行完代码块时`自动被调用。
- `new创建的对象`：将驻留在栈内存或自由存储区，`使用delete来释放内存时`，将自动被调用。
- `临时对象`：将在`结束对该对象的使用时`自动调用析构函数。

由于类对象过期时析构函数将自动被调用，因此必须有一个析构函数。
> 如果程序中没有提供析构函数，编译器将隐式地声明一个默认析构函数，并发现导致对象被删除的代码后，提供默认析构函数的定义。

程序例子code -----> 「[Stock10](./stock10)」

👉 小 Tips：`如果既可以通过初始化，也可通过赋值来设置对象的值，则是优先选择初始化方式`。

const成员函数，保证函数不会修改调用对象。C++的解决方法：将const关键字放在函数的括号后面。

```cpp
void show() const; //声明

void Stock::show() const; //函数定义的开头
```

只要类方法不修改调用对象，就应该将其声明为const。

对于析构函数来说，可以`没有返回类型（连void也没有）`，也`没有参数`，其名称为`类名称`前加上 `~`。

### 4. this指针

this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。所有的类方法都将this指针设置为调用它的对象的地址。
> 使用 `->运算符` 来访问类成员。

注意点

- 每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。如果方法需要引用整个调用对象，则可以直接使用表达式 *this。
在函数的括号后面使用const限定符将this限定为const，此时不能使用this来修改对象的值。

- 由于this是对象的地址，因此返回的不是this，而是对象本身，即 *this（将解除引用运算符* 用于指针，将得到指针指向的值）。

程序例子code -----> 「[Stock20](./stock20)」

### 5. 对象数组

声明对象数组的方法与声明标准类型数组相同。如：

```cpp
Stock mystuff[4]; //声明对象数组，其中包含了4个Stock对象的数()

const int STKS = 10;
Stock stocks[STKS] = {
    Stock("NanoSmart",12.5,20), //stock[0]
    Stock(), //使用构造函数Stock()来初始化stock[1]
    Stock("Nanolithic Obelisks",120,3.25) // stock[2]
};
// 使用 Stock(const std::string &co ,long n,double pr)初始化 stock[0] 和 stock[2]。其余的7个元素则使用默认构造函数来进行初始化。
```

初始化对象数组的方案：
> 要创建对象数组，则类必须有默认构造函数。

1. 使用默认构造函数创建数组元素
2. 花括号中的构造函数将创建临时对象
3. 将临时对象的内容复制到相应的元素中。

### 6. 类作用域

在类中定义的名称（如数据成员名和类成员函数名）的作用域味都为整个类，作用域为整个类的名称只在该类中已知，在类外不可知。因此可在不同类中使用相同的类成员名称而不会引起冲突。

类作用域意味着不能用外部直接访问类的成员（包括公有成员函数），则必须通过对象来调用公有成员函数。在定义成员函数时，必须使用作用域解析运算符。

```cpp
Stock sleeper("Exclusive Ore",100,0.25); // 创建对象
sleeper.show();// 使用对象去调用公有成员函数
show(); //不可用，因为不能直接调用方法

// 定义成员函数，使用作用域解析运算符
void Stock::update(double price)
{
    ......
}
```

在类声明或成员函数定义中，可使用未修饰的成员名称（未限定的名称），构造函数名称在被调用时，才能被识别（名称与类名称相同）。在其他的情况下，使用类成员名时，必须根据上下文使用`直接成员运算符（.）`、`间接成员运算符（->）`或`作用域解析运算符（::）`。例子：

```cpp
class Ik
{
    private:
        int fuss; //有类作用域
    public:
        Ik(int f = 9){fuss = f;} // fuss在类作用域内
        void ViewIk() const;
}；

void Ik::ViewIk() const //作用域解析运算符使用
{
    std::cout << fuss << std::endl; //fuss在作用域内调用类方法
}
...
int main()
{
    Ik * pik = new Ik;
    Ik ee = Ik(8); //构造函数在作用域内，则有类名
    ee.ViewIk(); // 类对象将ViewIK引入到作用域内（直接成员运算符）
    pik -> ViewIk(); // 间接产成员运算符
    ...
}
```

#### 6.1 作用域为类的常量

使符号常量的作用域为类很有用。例如，类声明可能使用字面值30来制定数组的长度。由于该常量对于所有对象来说都相同，则创建爱你一个由所有对象共享的常量也不错。你以为如下方式可行：

```cpp
class Bakery
{
    private:
        const int months = 12;// 声明常量？直接FAILS
        double costs[months];
        ...
}
```

直接不可行！！！！原因：声明类只是描述对象的形式，并没有创建对象（创建对象前，将没有用于存储值的空间）。

C++提供了两种方式在类中定义常量：

- 使用`关键字static`

    ```cpp
    class Bakery
    {
        private:
        // 直接在声明前使用关键字static，将常量直接与其他静态存储变量存储在一起，而不是存储在对象中
            static const int months = 12;
            double costs[months];
            ...
    }
    ```

- 在`类中声明一个枚举`

    ```cpp
    class Bakery
    {
        private:
            //枚举不会创建类数据成员，所有对象不包含枚举，months只是一个符号名称，编译器遇到它时会直接将值替换
            enum {months = 12}; 
            double costs[months];
            ...
    }
    ```

### 7. 抽象数据类型

**`抽象数据类型（Abstract Data Type，ADT）`**：以通用的方式来描述数据类型，而没有引入语言或实现细节。

类很适合用于描述ADT，公有成员函数接口提供了ADT描述的服务，类的私有部分和类方法的代码提供了实现（实现对类的用户隐藏）。

## 第十一章 使用类

### 1. 运算符重载

操作符重载（Operator Overloading）是一种形式的C++多态。

#### 1.1 概述

**`函数重载（函数多态）`**：定义多个名称相同但特征标（参数列表）不同的函数。
> 函数重载（function overloading）、函数多态（function polymorphism）。

C++允许将运算符重载扩展到用户定义的类型。要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：

```cpp
// op表示要重载的操作符符号，如 operator +()
operator op(argument-list)

// 如：operator []() 数组索引运算符
```

op必须是有效的C++运算符，不能虚构一个新的操作符号。

⚠️警告：不要返回指向局部变量或临时对象的引用。函数执行完毕之后，局部变量和临时对象将消失，引用将指向不存在的数据。

示例代码 ----> 「[mytime00 版本code](./mytime00)」

在添加了加法运算符重载的问题后，「[mytime10 版本code](./mytime10)」

#### 1.2 重载限制

- 重载后的运算符必须至少有一个是用户定义的类型。目的：防止用户对标准类型重载运算符。
- 使用运算符时，不能违反运算符原来的句法规则。不能改变优先级。
- 不能创建新运算符。如： operator **() 函数表示求幂（❌不允许）
- **`不能重载`**下面的运算符
  - `sizeof`运算符
  - `成员`运算符（`.`）
  - `成员指针`运算符（`.*`）
  - `作用域解析`运算符（`::`）
  - `条件`运算符（`:?`）
  - 一个`RTTI`运算符（`typeid`）
  - 强制类型转换运算符（`const_cast、dynamic_cast、reinterpret_cast、static_cast`）。

- 只能通过`成员函数重载`的操作符
  - `赋值`运算符（`=`）
  - `函数调用`运算符（`()`）
  - `下标`运算符（`[]`）
  - 通过`指针访问类成员`的运算符（`->`）

将常见的操作符进行重载，具体例子：「[mytime20 版本code](./mytime20)」

### 2. 友元简介

C++提供另外一种形式的访问权限：友元。友元有3种：

- 友元函数
- 友元类
- 友元成员函数

通过让函数成为类的友元，可以赋予该函数与类的成员函数系统的访问权限。

在为`类重载二元运算符时`（带两个参数的运算符）常常需要友元。

对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数，而原来的成员函数则按相反的顺序处理操作数。

通过友元函数，可以让非成员函数也可与类成员函数相同的访问权限。

#### 2.1 创建友元

- 创建原型

    创建`友元函数`，将其原型`放在类声明`中，并在`原型声明前加上关键字 friend`：

    ```cpp
    friend Time operator * (double m,const Time & t)
    /** operator*() 函数是在类声明中声明的，但不是成员函数，因此不能使用成员运算符来调用
     * operator*() 函数不是成员函数，但它与成员函数的访问权限相同
     */
    ```

- 编写函数定义
    因不是成员函数，所以不需要使用 `Time::` 限定符。**`不要在定义中使用关键字 friend`**。

    ```cpp
    Time operator*(double m, const Time & t) // 友元不用在函数定义中使用
    {
        Time result;
        long totalminutes = t.hours * mult * 60 + t.minutes * mult;
        result.hours = totalminutes / 60;
        result.minutes = totalminutes % 60;
        return result;
    }
    ```

#### 2.2 常用的友元：重载 `<< 运算符`

`<<运算符`是C和C++的`位运算符`，将值中的位左移。`ostream类`对该运算符进行重载，将其转换为一个输出工具。

`ostream类声明`中都包含相应的重载的 `operator<<()`定义。

```cpp
ostream & operator <<(ostream & os, const c_name & obj)
{
    os << ...; // 显示内容
    return os;
}
```

⚠️警告：只有在类声明中的原型才能使用`friend 关键字`。除非函数定义也是原型，否则不能在函数定义中使用该关键字。

### 3. 重载运算符：作为成员函数还是非成员函数

对于很多运算符来说，可选择使用成员函数或非成员函数来实现运算符重载。而非成员函数则必须是友元函数才能访问类的私有数据。

```cpp
// ---------------- Time 类 --- 注意：加法属于二元操作符（需要两个操作数）-----
Time operator+(const Time & t) const; //成员函数版本（一个操作数通过this指针隐式磁道没，而另一个则是作为函数参数显式传递）

friend Time operator+(const Time & t1,const Time & t2);// 非成员函数版本（友元函数，两个操作数都是作为参数传递）
```

⚠️注意：非成员版本的重载运算符函数所需的形参数目与运算符使用的操作数数目相同；而成员函数所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象。

```cpp
T1 = T2 + T3;

T1 = T2.operator+(T3); // 成员函数格式
T1 = operator+(T2,T3); //非成员函数格式
```

⚠️注意：在定义运算符是，必须选择其一，而不能同时选择两种格式，否则会出现二义性，从而导致编译错误。

### 4. 重载示例：矢量类

使用运算符重载和友元的类设计 ----- 一个表示矢量的类。

`矢量（vector）`是工程和物理中使用的一个术语，是有`大小`和`方向`的量。计算机科学版本的 vector模板类在 第 16 章。

![](/assets/images/2022-10-26-23-38-18.png)

程序代码中的示例 ------> 「[vector 矢量概述的代码示例](./vector)」

### 5. 类的自动转换和强制类型转换

将一个标准类型变量的值赋给另一种标准类型的变量时，如果两种类型兼容，则C++自动将该值转换为接收变量的类型。但是也会伴随精度丢失的情况发生。

#### 5.1 两种类型转换

在无法完成自动转换时，可以使用强制类型转换。

- 隐式转换

    ```cpp
    //使用构造函数创建一个临时对象并初始化，然后采用逐成员赋值的方式将临时对象的内容复制到myCat中，这种方式称为隐式转换。
    Stonewt(double lbs);
    Stonewt myCat;
    myCat = 19.6;
    // 只有接受一个参数的构造函数才能作为转换函数
    ```

    隐式转换是自动进行，而不需要显式强制类型转换。

- 显式转换

    将构造函数用于自动类型转换会出现意外情况，所以C++新特性使用 `关键字 explicit` 来关闭自动特性。

    ```cpp
    // 声明构造函数的格式
    explicit Stonewt(double lbs); //不隐式转换（显式转换）
    ```

只接受`一个参数的构造函数`定义了从`参数类型`到`类类型`的转换。如果在声明中使用`关键字 explicit`，则只用于`显式强制类型转换`。否则会用于如下的隐式转换。（避免存在`二义性`）

- 将Stonewt对象初始化为doubel值时
- 将double值赋给Stonewt对象时。
- 将double值传递给接受Stonewt参数的函数时。
- 上述任一情况下，使用可转换为double类型的内置类型时。

#### 5.2 转换函数

C++运算符函数 ----- 转换函数：用户自定义的强制类型转换，可进行类似使用内置强制类型转换一样的方式。

```cpp
operator typeName(); // typeName指要转换成的类型

operator double(); //转换为double类型的函数原型
```

**⚠️转换函数的注意点**：

- 必须是类方法：需要通过类对象来调用，从而告知函数要转换的值。
- 不能指定返回类型
- 不能有参数

> **转换函数没有返回类型、没有参数、但必须返回转换后的值（虽然没有声明返回值的类型）**

**C++为类提供的类型转换**

- 只有`一个参数的类构造函数`用于将类型与该参数相同的值转换为类类型。在构造函数声明中使用 `explicit`可防止隐式转换，而只允许显式转换。
- 被称为`转换函数`的特殊类成员运算符函数，用于将类对象转换为其他类型。

## 第十二章 类和动态内存分配

### 1. 动态内存和类

C++中使用 `new` 和 `delete` 运算符来动态控制内存，析构函数不可缺少，否则会导致很多新的编程问题的出现。有时必须重载赋值运算符，从而保证程序正常运行。

#### 1.1 静态类成员

静态类成员的特点：无论创建多少个对象，程序都只创建一个静态类变量副本（类的所有对象共享同一个静态成员）。

不能在`类声明中初始化静态成员变量`（声明描述了如何分配内存，但不分配内存）。可以在`类声明之外单独使用单独语句来进行初始化`（静态成员变量是单独存储，而不属于对象的组成部分）。

⚠️注意：静态数据成员在类声明中声明，在包含类方法的文件中的初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果`静态成员`是`整型`或`枚举型const`，则可以在`类声明中初始化`。

⚠️警告：在构造函数中使用`new来分配内存`时，必须在相应的`析构函数`中使用`delete来释放内存`。如果使用 `new[] （包括中括号）`来`分配内存`，则应使用`delete[]（包括中括号）`来`释放内存`。

自动存储对象被删除的顺序与创建顺序相反。

`静态成员函数`的声明中必须包含`关键字 static`，但如果函数定义是`独立`的，则其中不能包含`关键字static`。原因有二：

- 不能通过对象调用静态成员函数，甚至不能使用this指针。
- 静态成员函数不与特定的对象相关联，只能使用静态数据成员。

#### 1.2 特殊成员函数

C++提供的隐式成员函数：

- 默认构造函数，如果没有定义构造函数

    如果没有提供任何构造函数，C++将创建默认构造函数。

    ```cpp
    StringBad::StringBad() {} // 隐式默认构造函数
    ```

    编译器将提供一个不接受任何参数、也不执行如何操作的构造函数（默认的默认构造函数）。

- 默认析构函数，如果没有定义
- 复制构造函数，如果没有定义
  - 定义

        复制构造函数用于将一个对象复制到新创建的对象中。用于初始化过程中（包括按值传递），而不是常规的赋值过程。类的复制构造函数的原型如下：

        ```cpp
        Class_name(const Class_name &); //接收一个指向对象的常量引用作为参数
        ```
  - 何时调用？

        每当程序生成对象副本时，编译器都会使用复制构造函数。常见的情况：

    - 当函数按值传递对象时
    - 当函数返回对象时
    - 当编译器生成临时对象时

  - 默认的复制构造函数的功能

        默认的复制构造函数逐个复制非静态成员（`成员复制，也称为浅拷贝`），复制的是`成员的值`。

        ⚠️警告：如果类中包含了使用new初始化的指针成员，应当定义一个拷贝构造函数，以`复制指向的数据`，而不是指针。这种称为`深拷贝`。浅拷贝只拷贝指针值（拷贝指针信息）

- 赋值运算符，如果没有定义

  - 定义和原型函数

        C++允许`类对象赋值`，通过自动为`类重载复制运算符`来实现。函数原型如下：

        ```cpp
        Class_name & Class_name::operator=(const Class_name &);
        ```
  - 赋值运算符的作用

        解决默认赋值运算符不合适导致的问题。

  - 实现复制运算符（进行深拷贝）的注意点：
    - 目标对象可能引用以前分配的数据，所以函数应使用 delete[] 来释放数据。
    - 函数应当避免将对象赋值给自身：否则给对象重新赋值时，释放内存操作可能删除对象的内存。
    - 函数返回一个指向调用对象的引用。

- 地址运算符，如果没有定义

当使用一个对象来初始化另一个对象时，编译器将自动生成`复制构造函数（创建对象的一个副本）`。例如：

```cpp
StringBad(const StringBad &)
```

### 2. 在构造函数中使用new时的注意事项

使用new初始化对象的指针成员时必须小心。具体做法如下：

- 如果在构造函数中使用`new来初始化指针成员`，则应在`析构函数中使用delete`。
- new 和 delete必须相互兼容。`new`对应于`delete`，`new[]` 对应于 `delete[]`
- 如果有多个构造函数，则必须以相同的方式使用 new，要么带括号，要么都不带。
- 定义一个拷贝构造函数，通过深拷贝将一个对象初始化为另一个对象。

### 3. 返回对象的问题

当成员函数或独立的函数返回对象时，有3种返回方式

- 指向对象的引用

- 指向对象的const引用

- const对象

### 4. 使用指向对象的指针

使用对象指针时的注意事项

- 使用常规表示法来声明指向对象的指针。
- 将指针初始化为指向已有的对象。
- 可使用 new 来初始化指针，创建一个新的对象。
- 对类使用 new 将调用相应的类构造函数来初始化新创建的对象。
- 可使用 -> 运算符通过指针访问类方法。
- 可对对象指针应用解除引用运算符来获得对象。

### 2. 队列模拟

待更新

## 第十三章 类继承

C++类提供了类库来提高重用性。类库由类声明和实现构成，以源代码的方式提供，所以要修改满足不同的需求，就需要修改代码。

C++提供`类继承`来扩展和修改类。类继承从已有的类派生出新的类，而派生类继承原有类（基类）的特征，包括方法。

继承可以完成的工作

- 在已有类的基础上添加功能
- 可给类添加数据
- 可修改类方法的行为

### 1. 基类

从一个类派生出另一个类时，`原始类`称为`基类`，`继承类`称为`派生类`。

继承的声明格式（公有继承）：

```cpp
//public表面声明是一个公有基类，公有派生类
class leaves : public root
{
    ......
}

// 书中例子
class RatePlayer : public TableTennisPlayer //基类（原始类）：TableTennisPlayer，派生类（继承类）：RatePlayer
{
    ......
}
```

派生类对象（上述code中的RatePlayer）的特征：

- 派生类对象存储了基类的数据成员（派生类继承了`基类的实现`）
- 派生类对象可以使用基类的方法（派生类继承了`基类的接口`）

#### 1.1 构造函数：访问权限的考虑

⚠️注意：派生类不能直接访问基类的私有成员，而必须通过基类公有方法来进行访问私有的基类成员。具体来说，派生类构造函数必须使用基类构造函数。

`派生类构造函数`的要点

- 创建派生类首先创建基类对象
- 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
- 派生类构造函数应初始化派生类新增的数据成员。

```cpp
RatedPlayer::RatedPlayer（unsigned int r,const string &fn,const 
                         string &ln,bool ht）:TableTennisPlayer(fn,ln,ht) // :TableTennisPlayer(fn,ln,ht) 是成员初始化列表
{
   rating=r;
}
```

派生类对象的释放顺序与创建对象时的顺序相反（首先执行派生类的析构函数目，然后自动调用基类的析构函数）。

#### 1.2 派生类和基类之间的特殊关系

- `派生类对象`可以使用`基类的方法`，条件是`方法不是私有`的。
- `基类指针`可以在`不进行显式类型转换`的情况下`指向派生类对象`。
- `基类引用`可以在`不进行显式类型转换`的情况下`引用派生类对象`。

```cpp
// 基类：TableTennisPlayer，派生类：RatedPlayer
RatedPlayer rplayer(1140, "Mallory", "Duck", true);
rplayer.Name(); //通过基类方法来继承
TableTennisPlayer & rt = rplayer;
TableTennisPlayer * pt = &rplayer;
rt.Name(); // 使用引用方式来引用派生类对象
pt->Name(); //指针方式来指向派生类对象
```

`基类指针`或`引用`只能用于调用`基类方法`。因此，不能使用 rt 或 pt来调用派生类的 ResetRanking 方法。

C++中要求引用和指针类型与赋给的类型匹配，但这规则对于继承来说是一种单向例外，不可以将基类对象和地址赋给派生类引用和指针。

如果基类引用和指针可以指向派生类对象，则如下情况均可正常使用：

- 基类引用定义的函数或指针参数可用于基类对象或派生类对象。
  - 形参为基类引用时，可指向基类对象或派生类对象。
  - 形参为指向基类的指针的函数，可使用基类对象的地址或派生类对象的地址作为实参。
- 引用的兼容性问题允许将基类对象初始化为派生类对象。
- 可将派生类对象赋给基类对象。

### 2. 继承：is-a关系

C++中3种继承方式：

- 公有继承
- 保护继承
- 私有继承

公有继承是最常用的方式，建立一种 `is-a` 关系。即派生类对象也是一个基类对象，可对基类对象执行的任何操作，也可对派生类对象执行。

### 3. 多态公有继承

多态：同一个方法的行为随上下文而异。

实现多态公有继承的两种机制：

- 在派生类中重新定义基类的方法
- 使用虚方法

使用 `virtual` 方法，程序会根据`引用或指针指向的对象的类型`来选择方法，而不是根据`引用或指针类型`来选择方法。

如果要在派生类会重新定义基类的方法，通常将基类方法声明为虚的。即在`类方法`声明前加上 `virtual` 关键字。被virtual声明的类方法称为`虚方法`。

```cpp
class BrassPlus:public Brass
{
    private:
        ......
    public:
        ......
        virtual void ViewAcct() const; //虚方法
        virtual void Withdraw(double amt); // 虚方法
}
```

### 4. 静态联编和动态联编

`函数名联编`：将源代码中的函数调用解释为执行特定的函数代码块。

`静态联编（早期联编）`：在`编译过程中`进行联编。

`动态联编（晚期联编）`：编译器生成能够在`程序运行时选择正确的虚方法`的代码。

#### 4.1 指针和引用类型的兼容性

- `向上👆强制转换`：将派生类引用或指针 ---------> 基类引用或指针。⚠️公有继承不需要进行显式类型转换。
    > 向上强制转换是可传递的。

- `向下👇强制转换`：将基类指针或引用 ---------> 派生类引用或指针。如果不使用显式类型转换，则向下强制转换不允许使用。

- 隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++虚成员函数来能满足这种需求。

#### 4.2 虚成员函数和动态联编

编译器对`非虚方法`使用`静态联编`，而对于`虚方法`使用动态联编。

- 有两种类型联编的原因？
  - 效率

        动态联编为使程序可在程序运行阶段进行决策，则必须采取一些方法来跟踪基类指针或引用指向的对象类型，但会增加额外的处理开销。此时静态联编效率更高。

        C++的指导原则之一：不要为不适用的特性付出代价。仅当程序设计确实需要虚函数时，才使用它们。

  - 概念模型

- 虚函数的工作原理
C++规定了虚函数的行为，实现方法还是需要由编译器作者负责。

编译器处理虚函数的方法：给每个对象添加一个`隐藏成员`。隐藏成员中保存了一个`指向函数地址数组`的指针。这种数组称为`虚函数表（Virtual function table，vtbl）`。虚函数表中存储了为类对象进行声明的虚函数的地址。

使用虚函数时，在内存和执行速度方面存在的成本：

- 每个对象都将增大，增大量为存储地址的空间；

- 对于每个类，编译器都创建一个虚函数地址表（数组）；

- 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。

#### 4.3 虚函数的注意事项

- 在基类方法的声明中使用`关键字 virtual`，可使该方法在基类以及所有派生类（包括派生类的方法）都是虚的。

- 如果使用`指向对象的引用或指针`来`调用虚方法`，程序将使用对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为`动态联编`或`晚期联编`。

- 如果定义的类将被用作基类，则应将要在派生类中重新定义的类方法声明未为虚的。

##### 4.3.1 构造函数

**构造函数不能是虚函数**。派生类不继承基类的构造函数，所以将构造函数声明为虚的无意义。

##### 4.3.2 析构函数

**析构函数应声明为虚函数**，除非类不用做基类。

即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而 **应提供虚构函数，即使它不执行任何操作**。

##### 4.3.3 友元

**友元不能是虚函数**，因为设计的问题，友元不是类成员，而是通过让友元函数使用`虚成员函数`来解决。

##### 4.3.4 没有重新定义

如果`派生类没有重新定义函数`，将使用`函数的基类版本`。如果`派生类位于派生链`中，则将使用`最新的虚函数版本`。

##### 4.3.5 重新定义将隐藏方法

重新定义不会生成函数的两个重载版本，而是隐藏了基类版本。

- 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针，这种特性称为 `返回类型协变（Covariance of return type）`。
    > 允许返回类型随类型的变化而变化。⚠️注意：**只适用于返回值，不适用于参数**。

- 如果基类声明被重载，则应在派生类中重新定义所有的基类版本。

### 5. 访问控制：protected

**控制对类成员访问权限的三个关键字：`private、public、protected`**。

关键字 `protected` 和 `private`类似，在`类外`只能使用`公有类成员`来访问 `protected 部分中的类成员`。

private和protected的区别：派生类成员直接访问基类的保护成员，但不能直接访问基类的私有成员。

对外部而言，保护成员的行为与私有成员类似，对派生类来说，保护成员的行为与公有成员类似。

```cpp
// Brass类将balance成员声明为保护的
class Brass
{
    protected:
        double balance;
        ...
};
```

⚠️警告：最好对数据成员采用私有访问控制，不要使用保护访问控制，同时通过类方法使得派生类能够访问基类数据。

对成员函数来说，保护控制可以让派生类能够访问公众无法使用的内部数据。

### 6. 抽象基类

在类声明中包含纯虚函数时，则该类就是**`抽象基类（Abstract Base Class，ABC）`**。

C++通过使用`纯虚函数（pure virtual function）`提供`未实现的函数`。纯虚函数声明的结尾处为`=0`。

```cpp
class BaseEllipse //抽象基类
{
    private:
        ...
    public:
        ...
        virtual double Area() const = 0; //纯虚函数
};
```

如果在类声明中包含纯虚函数时，则不能创建该类的对象。

ABC描述的是至少使用一个纯虚函数的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现接口。
[]
ABC要求具体派生类覆盖其纯虚函数 -

### 7. 继承和动态内存分配

如果派生类也使用动态内存分配（使用new和delete进行），有如下几个技巧：

#### 7.1 情况1:派生类不使用new

假设基类使用动态内存分配：

```cpp
// Base Class Using DMA(Dynamic Memory Allocation)
class BaseDMA
{
    private:
        char *label;
        int rating;
    public:
        baseDMA(const char * l = "null", int r = 0);
        baseDMA(const baseDMA & rs); // 复制构造函数（处理内存分配）
        virtual ~baseDMA(); //虚析构函数
        baseDMA & operator=(const baseDMA & rs); //赋值运算符重载
        ......
};
```

如果在基类中已经使用了动态内存分配（已定义显式析构函数、复制构造函数和赋值运算符），则在派生类中无需使用动态内存分配。

```cpp
// derived class without DMA
class lackDMA:public baseDMA
{
    private:
        char color[40];
    public:
        ......
};
```

此时的派生类lackDMA类不需要定义显式析构函数、复制构造函数和赋值运算符。

#### 7.2 情况2:派生类使用new

如果基类和派生类也使用了动态内存分配：

```cpp
class hasDMA: public baseDMA
{
    private:
        char * style; // 构造函数中使用new
    public:
        ......
};
```

此时需要为派生类定义显式析构函数、复制构造函数和赋值运算符。对应的定义方法如下：

- 析构函数

    派生类析构函数自动调用基类的析构函数，故其自身职责：对派生类构造函数执行工作的清理。

    ```cpp
    baseDMA::~baseDMA()
    {
        delete [] label;
    }
    hasDMA::~hasDMA()
    {
        delete [] style;
    }
    ```

- 复制构造函数

    复制构造函数只能访问自身的数据，不能访问基类的私有数据，所以必须调用基类的复制构造函数来进行数据共享。

    ```cpp
    // 成员初始化列表将hasDMA引用传递给baseDMA构造函数。
    hasDMA::hasDMA(const hasDMA & hs):baseDMA(hs) //基类引用可以指向派生类型。
    {
        style = new char[std::strlen(hs.style) + 1];
        std::strcpy(style,hs.style);
    }
    ```

    所以，baseDMA复制构造函数将使用hasDMA参数的baseDMA部分来构造新对象的baseDMA部分。

- 赋值运算符

    派生类的显式赋值运算符必须负责将所有继承的baseDMA基类对象的赋值，可通过显式调用基类赋值运算符来进行该操作。

    ```cpp
    hasDMA & hasDMA::operator=(const hasDMA & hs) //hasDMA使用DMA，所以需要一个显式复制运算符
    {
        if(this == &hs)
            return *this;
        baseDMA::operator=(hs); // 与 *this = hs 相同
        delete [] style;
        style = new char[std::strlen(hs.style) + 1];
        std::strcpy(style, hs.style);
        return *this;
    }
    ```

#### 7.3 总结

当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的类方法来处理基类元素。三种方式来满足：

- 析构函数：`自动`完成
- 构造函数：通过在`初始化成员列表`中调用基类的复制构造函数来完成。否则会自动调用基类的默认构造函数。
- 赋值运算符：通过 `作用域解析运算符` 来显式调用基类的赋值运算符来完成。

#### 7.4 DMA和友元的继承

由于友元函数不能被继承，但是派生类应该如何使用基类的友元函数？

```cpp
// 基类baseDMA的友元函数
friend std::ostream * operator<<(std::ostream & os, const baseDMA & rs)
// 派生类hasDMA的友元函数
friend std::ostream & operator<<(std::ostream &os,const hasDMA & rs);
```

hasBMA可访问style成员，但不能访问基类baseDMA友元中的label和rating，所以通过使用基类baseDMA类的友元函数 operator<< 来对其进行强制类型转换，便于原型匹配选择正确的函数。

```cpp
std::ostream & operator<<(std::ostream & os, const hasDMA & hs)
{
 os << (const baseDMA &) hs; //直接通过强制类型转换的方式来进行
 os << “Style: ” << hs.style << endl;
 return os;
}
```

关于继承和内存动态分配的代码例子 -------> 「[继承和DMA 例子Code](./dma_and_friend_inheritence)」

### 8. 类设计回顾

C++可用于解决各种类型的编程问题，但不能将类设计简化成带编号的例程。

#### 8.1 编译器生成的函数

编译器会自动生成一些公有成员函数 -----> 特殊成员函数。

- 默认构造函数

  - 默认构造函数要么没有参数，要么所有的参数都有默认值。

  - 如果没有定义任何构造函数，编译器将定义默认构造函数，便于创建对象。

  - 如果在派生类构造函数中成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。
        > 如果基类此时没有构造函数，将导致编译错误。
  - 构造函数的作用：确保对象总能被正确的初始化。

- 复制构造函数

    复制构造函数接受其所属类的对象作为参数。使用复制构造函数的情况：

  - 将新对象初始化为一个同类对象。
  - 按值将对象传递给函数。
  - 函数将值返回对象。
  - 编译器生成临时对象。

    如果程序没有使用，则编译器提供原型，但不提供函数定义。

- 赋值运算符

  - 默认的赋值运算符用于处理同类对象之间的赋值。
        > **`初始化`**：语句创建新的对象；**`赋值`**：语句修改已有对象的值。
  - 编译器不会生成将一种类型赋给另一种类型的赋值运算符，所以要么显式定义，要么使用强制类型转换。前者容易导致编译器出现混乱，所以一般使用后者。

- 默认析构函数

#### 8.2 定义类（设计类）需要注意的问题

- **`构造函数`**

    用于创建新的对象，其他类方法只是被现有的对象调用，所以不能被继承。

- **`析构函数`**

    如果使用new进行动态内存分配，则一定要定义显式析构函数来完成类对象执行后的清理。基类应提供一个虚析构函数（即使不执行任何操作）。

- **`转换`**
    C++11支持用explicit。使用explicit允许进行显式转换，禁止隐式转换。

- **`按值传递对象与传递引用`**：

    编写使用对象作为参数的函数时，应`按引用传递对象`（不使用按值传递）。原因如下：

  - 提高效率
  - 在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。

    如果不修改引用，则将参数声明未const引用。

- **`返回对象和返回引用`**

  - 唯一区别：函数原型和函数头。
  - 应返回引用而不是返回对象的原因：返回引用可节省时间和内存。
  - ⚠️注意：函数不能返回临时对象的引用 -----> 函数结束，临时对象消失，所以引用不合法。

- **`使用const`**

  - 修饰参数 -----> 确保方法不修改参数。
  - 修饰方法 -----> 确保方法不修改调用它的对象。
  - 修饰返回引用的函数 -----> 确保引用或指针返回的值不能用于修改对象中的数据。

#### 8.3 公有继承的考虑因素

- is-a关系

    遵循 is-a 关系，如果派生类不是特殊的基类，则不要使用公有派生。

- 什么不能被继承？
  - 构造函数
  - 析构函数
  - 赋值运算符

- 私有成员与保护成员
  - 将基类成员设置私有可提高安全性，设置保护可简化代码编写，提高访问速度。
  - 但一般将基类的数据成员设为私有成员，而将方法设置为保护成员。

- 虚方法

    在设计基类时，必须确定是否将类方法声明为虚的。
  - 如果派生类需要重新定义方法，则在基类中将方法设置为虚的。
  - 如果不需要，则不必将其声明为虚的。

- 析构函数
  - 基类的析构函数应是虚的（virtual）。

- 友友函数

    友元函数不是类成员，所以不能被继承。
  - 如果希望派生类的友元能使用基类的友元，可通过强制类型转换符。
        > 将派生类引用或指针转换为基类引用或指针，然后使用转换后的来调用基类的友元。

#### 8.4 类函数的总结

![](/assets/images/2022-10-26-23-45-54.png)

## 第十四章 C++中的代码重用

C++的主要目标：促进代码重用。通过公有继承来实现这种目标机制。

### 1. 包含对象成员的类

通过动态内存分配来表示数组，使得数组长度不被限制。

#### 1.1 valarray类简介

`valarrat类` 由`头文件 valarray`支持。valarray被定义为一个模板类，以能够处理不同类型的数据类型。

模板特性意味着声明对象时，必须指定具体的数据类型。所以。valarray类来声明一个对象时，需要在`标识符valarray`后面加上`一对尖括号`，并在其中包含所需的数据类型。

```cpp
double gpa[5] = {3.1,3.5,3.8,2.9,3.3}       
valarray<double> v1;                    // double类型数组，大小为0
valarray<int> v2(8);                    // 8个int类型的元素数组
valarray<int> v3(10,8);                 // 8个int类型的元素数组，每个设置为10
valarray<doubl> v4(gpa,4);              // 4个元素数组，初始化
valarray<int> v5 = {20,32,17,9};        // 在C++11中，用来初始化列表
```

可以创建长度为0的数组、指定长度的空数组、所有元素被初始化为指定值的数组、用常规数组中的值来进行初始化的数组。

valarray类的一些方法：

- `operator[]()`：访问各个元素
- `size()`：返回包含的元素个数
- `sum()`：返回所有元素的总和
- `max()`：返回最大的元素
- `min()`：返回最小的元素

#### 1.2 Student类的设计

学生和其它类之间不是 `is-a关系`，而是 `has-a关系`。学生有姓名和一组考试分数。

`has-a 关系`的C++技术是组合（包含），即创建一个包含其他类对象的类。

```cpp
class Student
{
    // 声明私有数据成员
    private:
        string name;                // 使用string对象
        valarray<double> scores;    // 使用 valarray<double> 对象
        ...
    // 成员函数可以使用 公有接口 来修改 name和 scores对象。但在类的外部不可行（通过Student类的公有接口来访问）
}
```

#### 1.3 接口和实现

- 使用`公有继承`时，**`类可以继承接口`**。还会有`实现`（基类的纯虚函数提供接口，但不提供实现）
  - `获得接口`是 `is-a`关系的组成部分。

- 使用`组合`，类可以获得实现，但不能获得接口。
  - `不继承接口`是 `has-a` 关系的组成部分
  - `has-a` 关系上，类对象不能自动获得被包含对象的接口。

#### 1.4 C++和约束

C++包含让程序员限制程序结构的特性 ---- 使用 explicit 防止单参数构造函数的隐式转换。使用 const限制方法修改数据等。

原因：在编译阶段出现错误优于在运行阶段出现错误。

### 2. 私有继承

实现 `has-a` 关系的另外一个途径 ---- **`私有继承`**。

使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。意味着基类方法将不会成为派生对象公有接口的一部分，但可在派生类的成员函数中使用。

派生类不基础基类的接口。

#### 2.1 私有继承和组合的异同

- 相同点
  - 私有继承
    - 获得实现，但不获得接口。
    - 将对象作为一个未被命名的继承对象添加到类中。
  - 组合
    - 将对象作为一个命名的成员对象添加到类中。

- 不同点
  - 类将继承实现
  - 组合提供两个被显式命名的对象成员。
  - 私有继承提供两个无名称的子对象成员。
  - 组合使用对象名来调用方法
  - 私有继承使用类名 和 作用域解析运算符来调用方法。

要进行私有继承，使用关键字 `private` 而不是 `public` 来定义类。

#### 2.2 初始化基类组件

隐式继承组件而不是成员对象，会影响代码的编写。所以使用公有继承。

```cpp
// 使用组合的构造函数，直接使用成员名来标识构造函数
Student(const char * str, const double * pd , int n)
    : name(str),scores(pd,n) {} 

// 使用继承类，使用类名而不是成员名来标识构造函数
Student(const char * str, const double *pd, int n)
    : std::string(str), ArrayDb(pd,n) {} // ArrayDb 是 std::valarray<double> 的别名
```

#### 2.3 访问基类的方法

使用私有继承时，只能在派生类的方法中使用基类的方法。

- 在私有继承使得使用`类名`和`作用域解析运算符`来调用`基类的方法`
- 组合是直接使用对象名来调用方法。

```cpp
double Student::Average() const
{
  if (ArrayDb::size > 0)
    return ArrayDb::sum / ArrayDb::size();
  else
    return 0;
}
```

#### 2.4 访问基类对象

通过`强制类型转换`。将Student对象转换为string对象。

`指针this` 指向用来调用方法的对象，因此 `*this` 为用来调用方法的对象。

```cpp
const string & Student::Name() const
{
  return (const string &) *this; // 返回一个引用，引用指向用于调用方法的Student对象中的继承而来的string对象。
}
```

#### 2.5 访问基类的友元函数

用类名显式地限定函数名不适合友元函数。 **友元不属于类**，但是可以通过显式转换为基类来调用正确的函数。

```cpp
ostream & operator<<(ostream & os, const Student & stu)
{
  os << "Scores for " << (const string &) stu << " : \n";
  ...
}
```

#### 2.5 使用组合还是私有继承

多数选择程序员选择使用 **`组合`**。原因：

- 易于理解。
  - 类声明中组合表示被包含类的显式命名对象。代码可以通过名称引用对象
  - 继承会使得关系更抽象难懂。
- 继承会引起很多问题
  - 组合可以包含多个同类的子对象。
  - 继承只能使用一个对象（当对象都没有名称时，会难以区分）。

通常情况下：

- 应使用组合来建立 `has-a` 关系
- 如果新类需要访问原有类的`保护成员`，或者需要`重新定义虚函数`，则应使用`私有继承`。

### 3. 保护继承

保护继承是私有继承的变体。

在基类中使用 **`关键字protected`** 来进行声明。

```cpp
class Student : protected std::string, protected std::valarray<double>{
  ...
};
```

使用保护继承时，基类中的公有成员和保护成员都会变成派生类的保护成员。

- 使用 **`私有继承`** 时，第三代类将不能使用基类的接口。
  - 基类的公有方法在派生类中将变成私有方法。
- 使用 **`保护继承`** 时，基类的公有方法在第二代中将变成受保护的，所以第三代派生类可以使用。

![](/assets/images/2022-10-26-23-50-20.png)

### 4. 使用using重新定义访问权限

使用保护派生或私有派生时，基类的公有成员将成为保护成员或私有成员。

让基类的方法在派生类外可用的两种方式：

- 定义一个使用该基类方法的派生类方法
- 将函数调用包封装在另一个函数调用中。通过`using声明`来指出派生类可以使用特定的基类成员。（类似 using namespace std; 名次空间的方式）

`using` 声明只使用`成员名` ---- **`没有圆括号、函数特征标和返回类型`**。

```cpp
class Student : private std::string, private std::valarray<double>
{
  ...
  public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
    ...
};
```

### 5. 多重继承(MI)

使用多个基类的继承被称为 **`多重继承（multiple inheritance，MI）`** 。

MI描述的是`is-a`关系。

MI必须使用 `关键字public` 来限定每一个基类。原因：非特别指出，编译会认为是私有派生。

```cpp
// 从Singer 和 Waiter 公有派生出SingerWaiter
class SingerWaiter : public Waiter, public Singer {...};
// Singer 和 Waiter 都继承了一个 Worker组件，所以SingerWaiter则组合两个Woker组件
```

例子1 ： [代码](./workers0-code)

#### 5.1 MI可能带来的问题

- 从两个不同的基类基础同名方法
- 从两个或者更多基类那里继承了同一个类的多个实例

#### 5.2 程序worker的分析

把基类指针设置为派生对象中的基类对象的地址，有两种地址可选择，应使用类型转换来指定对象。

```cpp
Worker *pw1 = (Waiter *) &ed;
Worker *pw2 = (Singer *) &ed;
```

- 虚基类
  - 虚基类使得从多个类（基类相同）派生出的对象只继承一个基类对象。在类声明中使用关键字 `virtual` 来指示派生时，基类则成为`虚基类`。
  - C++在基类是虚的时，禁止信息通过中间类自动传递给基类。
  - 如果不希望`默认构造函数`来构造`虚基类对象`，则需要显式地调用所需的基类构造函数。
  
如果类有间接虚基类，则除非只需要使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。

在多重继承中，每个直接祖先都有`一个相同的函数`（如Show()），使得派生类调用此函数时`存在二义性`。此时需要使用`作用域解析运算`符来澄清编程者的意图。

```cpp
SingerWaiter newhire("Elise Hawks",2005,6,soprano)
newhire.Singer::Show();
```

- 如果基类是虚基类，派生类将包含基类的一个子对象。
- 如果基类不是虚基类，派生类将包含多个子对象。

如果类从不同的类哪里继承了两个或者更多的同名成员（数据或方法）则使用该成员名时，通过使用虚基类，某个名称优先于其他所有名称，则使用，如果不使用限定符，也不会导致二义性。

### 6. 类模板

C++模板提供参数化（parameterised）类型：能够让类型名作为参数传递给接收方来建立类或函数。

#### 6.1 定义类模板

模板类的代码定义：

```cpp
template <typename Type> // 模板类型
template <class Type> // 模板类
```

- `template` 告诉编译器，将要定义一个模板，尖括号中的内容相当于函数的参数列表。
- 关键字 `class` 看作变量的类型名，变量接受类型作为其值，把Type看作是该变量的名称。
- Type 表示一个通用的类型说明符。在使用模板时，使用实际的类型替换它。

如果在类声明中定义了方法（内联定义），则可以省略模板前缀和类限定符。

模板类不是函数，不能单独编译。

模板必须和特定的`模板实例化`请求一起使用。一般是使将所有模板信息放在`一个头文件`中。

#### 6.2 使用模板类

声明模板类的`对象`，必须`显式地提供所需的类型`。

```cpp
Stack<int> kernels; // 存储int类型的栈类
```

#### 6.3 数组模板和非类型参数

```cpp
template <class T, int n>
```

- class 指出T为`类型参数`，int指出n的类型。这种参数称为`非类型（non-type）`或`表达式参数`。
- 表达式参数可以是`整型`、`枚举`、`引用`或`指针`。

**`模板代码不能修改参数的值，也不能使用参数的地址。`**

实例化模板时，用做表达式参数的值必须是`常量表达式`（`#define`或者`const`定义的常数）。

- 表达式参数的优缺点
  - 优点
    - 构造函数使用new和delete来管理堆内存，但它为自动变量维护的内存栈，使得执行速度更快。
  - 缺点
    - 每种数组大小都会生成自己的模板。

#### 6.4 模板多功能性

模板类的三个功能：

- 用作基类

  ```cpp
  template <typename Type>
  class GrowArray : public Array <Type> {...};
  ```

- 用作组件类
  - 模板可以包含多个类型参数。

    ```cpp
    template <class T1, class T2>
    {
      private:
        T1 a;
        T2 b;
      public:
        T1 & first();
        T2 & second();
        ...
    };
    ```

- 默认类型模板参数
  - 可以为类型参数提供默认值

    ```cpp
    template <class T1, class T2 = int> class Topo {...};
    // 如果省略了T2的值，编译器会默认使用 int
    ```

  - 不能为`函数模板参数`提供默认值。但可为`非类型参数`提供默认值。

#### 6.5 模板的具体化

`隐式实例化`、`显式实例化`和`显式具体化`，统称为 **`具体化`** 。

`模板`使用 `泛型` 的方式`描述类`，`具体化`是使用`具体化的类型`生成`类声明`。

- 隐式实例化
  - 声明一个或多个对象，指出所需的类型，而编译器使用通用模板提供的处方生成具体的类定义。

    ```cpp
    ArrayTP <int, 100> stuff;
    ```

- 显式实例化
  - 当使用关键字 template 并指出所需类型来声明类时，编译器将生成类声明的显式实例化。
  - 声明必须位于模板定义所在的名称空间中。

    ```cpp
    template class ArrayTP<string, 100>; // 虽然没有创建或提及类对象，编译器也将生成类声明（包括方法定义）
    ```

- 显式具体化
  - 格式如下：

    ```cpp
    template <> class Classname <specialized-type-name> {...};
    // 显式具体化的例子
    template <> class Pair<int,int> {...};
    ```

- 部分具体化
  - 部分限制模板的通用性。

    ```cpp
    // 通用模板
    template <class T1, class T2> class Pair {...};
    // 
    template <class T1> class Pair<T1,int> {...}; // T1 保持不变，但是T2 被具体化为 int
    ```

  - 关键字 `template` 后面的 `<>声明` 的是没有被具体化的类型参数。
  - 如果多个模板可供选择，编译器将优先使用具体化程度最高的模板。
  - 如果提供的类型不是指针，则编译器将使用通用版本。
  - 日过提供的是指针，则编译器将使用指针具体化版本

#### 6.6 成员模板

模板可用作结构、类或模板类的成员。

```cpp
// template member
#include <iostream>
using std::out;
using std::cin;
using std::endl;

template <typename T>
class beta
{
  private:
    template <typename V> // 
    class hold
    {
      private:
        V val;
      public:
        hold(V v = 0) : val(v) {}
        void show() const {cout << val << endl; }
        V value() const {return val;}
    };
    hold<T> q;    // template object
    hold<int> n; // template object
  public:
    beta(T t, int i) : q(t), n(i) {}
    template<typename U> // template method
    U blab(U u,T t) {return (n.Value() + q.Value() * u / t;}
    void Show() const {q.Show(); n.Show();}
};
```

模板可以嵌套，所以语法为：

```cpp
template <typename T>
  template <typename V>
// 不能使用如下语法
template<typename T, typename V>
```

#### 6.7 使用模板作为参数

模板可以包含 **类型参数（typename T）** 和 **非类型参数（int n）**。

示例：

```cpp
template <template <typename T> class Thing>
class Grab
```

- 模板参数是 template<typename T> class Thing，其中template <typename T> class 是类型，Thing 是参数。

#### 6.8 模板类和友元

模板类声明也可以友元。模板的友元分为3类：

- 非模板友元
  - 在模板类中声明的一个常规友元函数，称为模板所有实例化的友元。

    ```cpp
    template<class T>
    class HasFriend
    {
      public:
        friend void counts();
        ...
    };
    ```

  - 当为友元函数提供模板类参数，必须指明具体化。

    ```cpp
    template <class T>
    class HasFriend
    {
      friend void report(HasFriend<T> &);// 具体化之后，就会变成约束模板友元
    };
    ```

- 约束模板友元：友元的类型取决于类被实例化时的类型。
  - 在`类外声明`的模板`具体化`。
  - 2个步骤：
    - 在类定义的前面声明每个模板函数

      ```cpp
      template <typename T> void counts();
      template <typename T> void reports(T &);
      ```

    - 在函数中再次将模板声明为友元。根据类模板参数的类型声明具体化。

      ```cpp
      template <typename TT>
      class HasFriendT
      {
        friend void counts<TT>();
        friend void report <HasFriendT<TT> &>;
        ...
      };
      ```

- 非约束模板友元：友元的所有具体化都是类的每一个具体化的友元。
  - 在`类内部`声明模板，可以创建`非约束友元函数`。

    ```cpp
    template <typename T>
    class ManyFriend
    {
      template <typename C,Typename D> friend void show2(C &, D &)
      ...
    };
    // 实现使用方式
    template <typename C, typename D> void show2(C & c, D & d)
    {
      ...
    }
    ```

#### 6.9 模板别名（C++11）

- 使用 `typedef` 为模板具体化指定别名

  ```cpp
  typedef std::array<double,12> arrd;
  arrd gallons; // gallon type : std::array<double,12>
  ```

- 使用 `using name = type` 于非模板，此时与常规的typedef等价。

  ```cpp
  template <typename T>
  using arrtype = std::array<T,12>; // arrtype定义为一个模板别名
  ```

## 第十五章 友元、异常和其它

### 1. 友元

友元函数用于类的扩展接口   中，类中不仅可以使用友元函数，也可以将类作为友元。

友元类的所有方法都可以访问原始类的`私有成员`和`保护成员`。

在一个类中将另一个类声明为友元。

```cpp
friend class Remote
```

友元声明可以位于公有、私有或者保护部分，其所在的位置无关紧要。

如果要将`友元类`中的特定的`类成员`解析作为`原始类`的`友元`，无需将整个类作为友元。

```cpp
class Tv
{
    friend void Remote::set_chan(tv & t, int c);
    ...
};
```

将类声明为友元时，需要注意：将类声明放在包含友元类的前面。 这种方法称为 **`前向声明（forward declaration）`** 。

```cpp
class Tv;  // 前向声明
class Remote {...};

class Tv {...};
```

`内联`函数的链接性是`内部`的，意味着函数定义必须在`使用函数的文件`中。也可将定义放在`实现文件`中，但必须删除 `关键字inline`，此时的链接性是`外部`的。

将类成为彼此的友元的实现方式。例如：

```cpp
class Tv
{
    friend class Remote;
    public:
        void buzz(Remote & r);
        ...
};
class Remote
{
    friend class Tv;
    public:
        void Bool volup(Tv & t) {t.volup();}
};
inline void Tv::buzz(Remote & r)
{
    ...
};
```

### 2. 嵌套类

在C++中，可以将类声明放在另一个类中。在另一个类中声明的类被称为 **`嵌套类（nested class）`**。

当类声明位于公有部分时，才能包含类的外面使用嵌套类，而且必须使用作用域解析运算符。

对类进行嵌套和组合不同。

- 组合将`类对象`作为另一个类的`成员`。
- 对类进行嵌套`不创建类成员`，而是定义一种`类型`（类型仅包含嵌套类声明的类中有效）。

对类进行嵌套是为了实现另一个类，并避免名称冲突。

嵌套类的访问权限控制

- 嵌套类的`声明位置`决定了嵌套类的`作用域`，决定了程序的`哪些部分`可以创建其类的`对象`。
- 和其它类一样，嵌套类的公有部分、私有部分和保护部分控制了对类成员的访问。

嵌套类访问的两种方式：

- 作用域

![](/assets/images/2022-10-27-10-34-30.png)

- 嵌套类的作用域为包含它的类，在类外部使用，则需要使用`类限定符`。

- 访问控制
  - 对嵌套类访问控制规则与常规类相同。
  
    类声明的位置决定了类的作用域可见性。
  - 类可见后，访问控制规则（公有、保护、私有、友元）将决定程序对嵌套类成员的访问权限。

### 3. 异常

异常是C++相对较新的功能，早期老编译器中可能会没有实现，但新的编译器中则是默认关闭了该特性。所以需要使用编译器选项来开启。

#### 3.1 返回abort()

调用位于头文件`cstdlib（或stdlib.h）`的`Abort()` 函数。
  
典型实现：想标准错误（即cerr使用的错误流）发送消息 `abnormal program termination（程序异常终止）` ，然后 `终止程序` 。还返回一个随实现而异的值，告知OS（如果程序是由另一个程序调用，则告诉父进程），处理失败。

- `abort()` 是否刷新文件缓冲区（用于存储读写到文件中的数据的内存区域）取决于实现。
- `exit()`：会刷新文件缓冲区，则不显示消息。

一般情况下，显示程序的异常中断消息随编译器而不同。

#### 3.2 程序错误码

一种比异常终止更灵活的方式：使用函数的返回值来指出问题。

任何数值都是有效的返回值，所以不存在可用于指出问题的特殊值。

一般使用`指针参数`或者`引用参数`来将`值返回`给`调用程序`，并使用函数的`返回值`来指出`成功`还是`失败`。

#### 3.3 异常机制

C++异常是对程序运行过程中发生的异常情况的一种响应。

对异常的处理有3个组成部分：

- 引发异常
  - `关键字throw` 表示`引发异常`，后面`紧跟值`用来指出`异常特征`。
- 使用`处理程序`捕获异常
  - `关键字catch` 表示`捕获异常`，后面括号中紧跟`类型声明`来指出`异常处理程序要响应的异常类型`。其后的代码块则指出采取的措施。
- 使用 `try块`
  - 标识特定的异常`可能被激活的代码块`，后面紧跟`一个`或`多个catch块`。
  - 表面需要注意代码引起的异常。

```cpp
#include <iostream>
double hmean(double a,double b);

int main()
{
    double x,y,z;
    std::cout << "Enter tow number :";
    while (std::cin >> x >> y)
    {
        try{
            z = hmean(x,y); // 如果程序输入的值不对，则会使用catch块来对异常进行处理
        }
        catch (const char *s){
            std::cout << s << std::endl;
            std::cout << "Enter a new pair of numbers :";
            continue; // 结束while循环的剩余部分，重新从while语句开始
        }
        std::cout <<"Harmonic mean of " << x << " and " << y << " is " << z <<std::endl;
        std::cout << "Enter next set of number <q to quit> : ";
    }
    std::cout << "Bye !! \n";
    return 0;
}

double hmean(double a ,doubel b)
{
    if (a == -b)
    // throw 用于执行返回语句，会终止函数的执行
    // throw不是将控制权返回给调用程序，而是导致程序沿函数调用序列后退，直到找到包含try块的函数
        throw "bad hmean() arguments : a = -b not allowed ";
    return 2.0 * a * b / (a + b);
}
```

#### 3.4 异常规范和C++11

异常规范是C++98中的一项功能，在C++11中已摒弃。但也需要了解：

```cpp
double harm(double a) throw(bad_thing); // 可能会抛出异常，只会抛出 bad_thing 类型的异常
double marm(double) throw(); // 不会抛出异常
```

`throw()`部分是异常规范，可能出现在`函数原型`和`函数定义`中，可包含`类型列表`，也可不包含。

异常规范的两个作用：

- 告知可能需要使用 **`try块`**。
- 让编译器添加执行运行阶段`检查代码`是否违反异常规范。

C++11中支持了一种特殊的异常规范：使用新增的 **`关键字noexcept`** 指出函数不会引发异常。

```cpp
double marm() noexcept; // 
```

#### 3.5 栈解退

当函数调用出现异常而终止，则程序释放栈中的内存，但不会释放栈的第一个返回地址后停止，而是继续释放栈，直到找到第一个 try块 中的返回地址，这个过程叫 **`栈解退`**。

异常机制将负责释放栈中的自动变量。

#### 3.6 其它异常特性

引发异常时编译器总是`创建一个临时拷贝`，即使异常规范和catch块中指定的是引用

引用作为返回值的原因：避免创建副本以提高效率。

如果有一个异常类继承层次结构，排序catch块的规则：将捕获位于`层次结构最下面`的异常类的`catch语句`放在`最前面`，将`捕获基类异常`的`catch语句`放在`最后面`。

如果不知道异常的类型，方法是省略号来捕获任何异常。

```cpp
catch () {/* statement */} // catch any type exception
```

如果可以预知一些异常类型，类似于switch语句的使用。

```cpp
try{
  duper();
}
catch(bad_3 &be)
{
  // statement
}
catch(bad_2 &be)
{
  // statement
}
catch(bad_1 &be)
{
  // statement
}
catch(bad_hmean &h)
{
  //statement
}
catch(...)
{
  // statement
}
```

#### 3.7 exception类

C++异常的主要目的：设计容错程序时避免一些错误处理方式。

在C++中 `exception头文件`中定义了 `exception类`，类中的 `what() 虚拟成员函数`，会返回`一个字符串`，字符串的特征随实现而异。

```cpp
#include <exception>
// 派生多个异常来处理
class bad_hmean : public std::exception
{
  public:
    const char * what() {return "bad arguments to hmean()";}
    ...
};
class bad_gmean : public std::exception
{
  public:
    const char * what() {return "bad arguments to gmean() ";}
    ...
};

// 直接使用一个基类来处理
try {
  ...
}
catch(std::exception & e)
{
  cout << e.what() << std::endl;
}
```

C++定义的基于`exception`的异常类型

- `stdexcept`异常类
  - `头文件stdexcept`定义的其它几个异常类，例如：`logic_error` 和 `runtime_error类`，都是从`公有方式`从exception派生而来。

    ```cpp
    class logic_error : public exception {
      public:
        exception logic_error(const string& what_arg);
        ...
    };
    class domain_error : public exception {
      public:
        explicit domain_error(const string& what_arg);
        ...
    }
    ```

  - 这些类的构造函数接受一个string对象作为参数，参数提供了方法 `what()` 以 C风格字符串方式返回`字符数据`。

    - `logic_error` 派生出来用于报告错误类型的类还有：
      - 逻辑错误，`任何阶段`
      - `domain_error`：传递给函数的参数不在定义域内而引发异常
      - `invalid_error`：传递了一个意料之外的值
      - `length_error`：指出没有足够的空间来执行所需的操作。
      - `out_of_bounds`：用于指示索引错误。
    - runtime_error 类型派生出来的类：
      - 错误发生在`运行阶段`
      - range_error：不在函数允许的范围内，和上溢、下溢无关。
      - overflow_error：上溢。`整型`和`浮点型`都有可能。
      - underflow_error：下溢。要发生在`浮点数计算`。

  - `每一个类`都有自己的`构造函数`，使 `what()方法` 能够返回的字符串。

- bad_alloc异常和new
  - new 请求的内存`分配失败`，则会引发 `bad_alloc`的异常错误。
  - 数组中最为常见。

- 空指针和new
  - new 分配内存失败，则会返回一个`空指针`。也是从`exception类`派生而来。所以C++标准提供了用法：

    ```cpp
    int * pi = new (std::nothrow) int;
    int * pa = new (std::nowthrow) int[500];
    ```

#### 3.8 异常丢失

异常被引发后，会导致问题的两种情况：

- **`意外异常（unexpected exception）`**：在带异常规范的函数中引发，但必须与规范列表中的某种异常匹配。
  - 可以通过调用 `terminate()`（默认行为）、`abort()` 或者 `exit()` 来终止程序
  - 引发异常

- **`未捕获异常（uncaught exception）`**：在没有try和catch块外抛出的异常。
  - 不会导致程序立即异常停止。

**引发异常(第二种选择)的结果取决于`unexpected_handler函数`所引发的异常以及引发意外异常的函数的异常规范**：

- 如果新引发的异常与原来的异常规范 **`匹配`**，则程序将从那里开始进行正常处理，即寻找与新引发的异常匹配的catch块。基本上是**`用预期的异常取代意外异常`**。
- 如果新引发的异常和原来的异常规范 **`不匹配`**，切异常规范中没包括 `std::bad_exception` 类型，则程序调用 `terminate()`。`bad_exception` 是从 `exception类`派生而来。声明位于`头文件execption`中。
- 如果新引发的异常与原来 **`不匹配`**，且`原来的异常规范`中包含 `std::bad_exception` 类型，则不匹配的异常被 `std::bad_exception` 异常所取代。

如果要捕获所有的异常，则方法如下：、

```cpp
// 1. 确保已声明异常头文件
#include <exception>
using namespace std;

// 2. 设计替代函数，将意外异常转换为 bad_exception 异常
void myexception()
{
  throw std::bad_exception {};
}

// 3. 将bad_exception 类型包含在异常规范中，并添加到catch块中
double Argh(double,double) throw(out_of_bounds, bad_exception);
...
try {
  x = Argh(a,b);
}
catch (out_of_bounds & ex)
{
  ...
}
catch (bad_exception & ex)
{
  ...
}
```

### 4. RTTI

**`RTTI（Runtime Type Identification，运行阶段类型识别）`**，C++11中新添加的新特性。

RTTI旨在为程序在运行阶段`确定对象的类型`提供一种标准方式。

**`RTTI只适用于包含虚函数的类`**。

C++中支持RTTI的3个元素

- `dynamic_cast`运算符：将使用一个指向基类的指针类生成一个指向派生类的指针，否则该运算返回0 ---- 空指针。
- `typeid`运算符：返回一个指出对象的类型的值
- `type_info`结构：存储有关特定类型的信息。

只有将RTTI用于包含`虚函数`的`类层次结构`，原因在于只有对于这种类层次结构，才应该将派生类对象的地址赋给基类指针。

#### 4.1 `dynamic_cast` 运算符

是最常用的RTTI架构。

只有指针类型与对象的类型（或对象的直接或间接基类的类型）相同的类型转换才一定是安全的。

语法格式：

```cpp
Superb *pm = dynamic_cast<Superb *pg> // 如果类型检查转换成功，则直接返回并进行赋值，否则得到一个空指针。
```

即使编译器支持RTTI，但在默认情况下，也可能是关闭该特性。

`dynamic_cast` 也可以用于引用。因为没有与空指针对应的引用值，所以无法使用特殊的引用值来指示失败。所以失败了，就会引发 `bad_cast` 的异常。

```cpp
try {
  Superb & rs = dynamic_cast<Superb &> (rg);
  ...
}
catch (bad_cast &) {
  ...
};
```

#### 4.2 `typeid` 运算符 和 `type_info` 类

`typeid` 运算符使能够确定`两个对象`是否为`同种类型`。接受两种参数：

- 类名
- 结果为对象的表达式

`typeid` 运算符返回一个`type_info对象的引用`，其中 `type_info` 在`头文件 typeinfo`中定义的一个类。

`typ_info类` 重载 `==` 和 `!=` 运算符，以便于使用对类型进行比较。

示例

```cpp
typeid(Magnificent) == typeid(*pg) // 将pg指向一个 Magnifgicent 对象，表达式返回结果为True，否则为False。
```

`typeid`测试用来`选择一种操作`，因为操作不是类的方法，所以 ~~不能通过类指针来调用它~~。

### 5. 类型转换运算符

假设 High 和 Low 是两个类。

通过4种类型转换运算符来使得转换过程增加规范。

- dynamic_cast
  - 能够在类层次结构中进行向上转换，而不允许其他转换。

    ```cpp
    dynamic_cast <type_name> (expression) // 判断expression是否可以转换成为 type_name 类型
    ```

- const_cast
  - 用于执行`只有一种用途的类型转换`，即改变值为`const`或者`volatile`。语法和 dynamic_cast相同

    ```cpp
    // 语法格式
    const_cast <type_name> (expression) // 删除const属性，使变成可修改对象
    // 示例
    High bar;
    const High *pbar = &bar;
    High *pb = const_cast <High *> (pbar); // 让*pb可成为一个用于修改bar对象值的指针。删除const属性
    ```

- static_cast
  - type_name 和 expression互相隐式转换为其所属的类型时，转换才合法，否则将出错。

    ```cpp
    static_cast <type_name> (expression)
    ```

- reinterpret_cast
  - 转换适用于依赖于实现的底层编程技术，具有不可移植性。
  - 不做任何处理，也不能删除const属性
  - 不支持所有的类型转换
    - 可以将指针类型转换为足以存储指针表示的类型，但不能将指针转换为更小的整型或者浮点型。
    - 不能将函数指针转换为数据指针。

  ```cpp
  reinterpret_cast <type_name> (expression)
  ```

## 第十六章 string类和标准模板库

### 1. string类

C语言在 string.h（C++中为cstring）提供了一系列的字符串函数。

#### 1.1 构造字符串

`string` 实际上是`模板具体化 basic_string<char>` 的一个 `typedef`，同时省略了与内存管理相关的参数。

![](/assets/images/2022-10-27-10-37-03.png)

- `size_type` 依赖于实现的整型，是在`头文件 string`中定义的。
- `string类` 将`string::npos`定义为字符串的最大长度，通常为 `unsigned int`的最大值。

#### 1.2 string类输入

在C-风格字符串，有3种方式：

```cpp
char info[100];
cin >> info;            // 读取字符
cin.getline(info,100); // 整行读取，舍弃 \n
cin.get(info,100);      // 整行读取，保留 \n
```

对于string对象，有2种方式：

```cpp
string stuff;
cin >> stuff;       // 读取字符
getline(cin,stuff); // 读取整行内容，舍弃\n
```

两个版本的getline() 都有一个可选参数，用于指定使用某个字符来确定输入的边界。

```cpp
// 读到 : 就舍弃 :
cin.getline(info,100,':');
getline(stuff,':');
```

对于string版本的`getline()` 函数从输入`读取字符`，并将其存储到`string对象`中，直到发生三种情况之一：

- 读到`文件尾`
  - 输入流的`eofbit`将被设置，其对应的方法 `fail()` 和 `eof()` 都会返回true。
- 遇到`分界字符`（默认是`\n`）
  - 删除分界符，不存储
- 读取的`字符数达到最大允许值`（string::nops 和可供分配的内存字节数中较小的一个）
  - 设置输入流中的 eofbit，让其方法 fail() 返回 true。

输入流对象有一个`统计系统`，用于跟踪流的错误状态。

- 系统中如果检测到`文件尾`后将设置 `eofbit寄存器`
- 检测到`输入错误`时将设置 `failbit寄存器`
- 出现`无法识别的故障`时将设置 `badbit寄存器`。
- `一切顺利`则设置 `goodbit寄存器`。

#### 1.3 使用字符串

string类对象对全部 6个关系运算符都进行了重载。

- 如果在机器序列中，一个对象位于另一个对象的前面，则前者小于后者
- 如果机器序列为ASCII码，则小写数字大于大写字符。

通过确定`字符串的长度`来比较大小，使用 `size()` 和 `length()` 成员函数返回字符串中的`字符数`。

```cpp
if (snake1.length() == snake2.size())
    cout << "both strings have the same lengt \n";
```

在字符串中搜索给定的子字符串或字符。
|方法原型|方法描述|
|:--|:--|
|`size_type find(const string &str, size_type pos = 0) const`|从字符串的pos位置开始，查找子字符串str，如果找到，则返回子字符串首次出现时其首字符的索引，否则返回 `string::npos`|
|`size_type find(const char * s,size_type pos = 0)const`|从字符串的pos位置开始，查找子字符串s，如果找到，则返回子字符串首次出现时其首字符的索引，否则返回 `string::npos`|
|`size_type find(const char *s,size_type pos = 0,size_type n)`|从字符串的pos位置开始，查找s的前n个字符组成的子字符串，如果找到，则返回子字符串首次出现时其首字符的索引，否则返回 `string::npos`|
|`size_type find(char ch, size_type pos = 0)const`|从字符串的pos位置开始，查找字符串ch，如果找到，则返回字符出现的`位置`，否则返回 `string::npos`|

string库提供了相关的方法（其重载函数特征标都与`find()` 方法相同。）：

- `rfind()`：查找子字符串或字符最后一次出现的位置。
- `find_first_of()`：在字符串中查找参数中任何一个字符`首次出现`的位置。
- `find_last_of()`：在字符串中查找参数中任何一个字符`最后一次出现`的位置。
- `find_first_not_of()`：在字符串中查找`不在参数`中的字符`第一次出现`的位置。
- `find_last_not_of()`：在字符串中查找`不在参数`中的字符`最后一次出现`的位置。

`+=运算符`的某个重载版本使得能够将`一个字符`附加到`字符串`中。

#### 1.4 字符串的额外函数方法

- `capacity()`：返回当前分配给字符串的内存块的大小。
- `reserve()`：能够请求内存块的最小长度。

#### 1.5 字符串种类

string类看作是基于char类型模板的具体化

```cpp
// Allocator 是管理内存分配的类，对于各种字符类型，都有预定义的allocator模板具体化，都是默认的，使用new和delete。
template <class charT, class traits = char _traits<charT>,
        class Allocator = allocator<charT> > 
basic_string {...};
```

模板 basic_string 有4个具体化，每一具体化都有一个 typedef名称：

```cpp
typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string; // C++11
typedef basic_string<char32_t> u32string; // C++11
```

### 2. 智能指针模板类型

智能指针是行为类似于指针的`类对象`。

目的：将开发者将申请未释放的`内存回收`，从而`避免内存泄漏`。

#### 2.1 使用`智能指针`

智能指针类一共有3种：

- `auto_ptr`
- `unique_ptr`
- `shared_ptr`

通过`new`获得（直接或间接）的`地址`赋给`对象`。当智能指针过期时，其`析构函数`将使用`delete`来`释放内存`。

如果将`new`返回的地址赋给对象后，无需关注释放内存。当智能指针过期时，内存将`自动释放`。

`auto_ptr` 和`常规指针`在行为方面的差别：`share_ptr` 和 `unique_ptr` 的行为 和 `auto_ptr` 相同。

![](/assets/images/2022-10-27-10-39-56.png)

使用常规指针实现：

```cpp
void remodel(std::string &str)
{
  std::string * ps = new std::string(str);
  ...
  if(weird_thing())
    throw exception();
  str = *ps;
  // 如果出现异常，delete不会被执行，会导致内存泄漏
  delete ps;
  return;
}
```

使用智能指针的3个步骤：

- 包含`头文件memory`
- 将指向`string的指针`替换为`指向string的智能指针对象`
- 删除`delete`语句

所以将remodel()函数使用智能指针重写为：

```cpp
#include <memory>
void remodel(std::string & str)
{
  std::auto_ptr <std::string> ps (new std::string(str));
  ...
  if (weird_thing())
    throw exception();
  str = *ps;
  // 不需要delete ps;语句
  return;
}
```

[书中代码示例](smrtsptrs.cpp)

#### 2.2 智能指针的注意事项

- `auto_ptr` 和 `unique_ptr` 都是采用所有权模型。
- `unique_ptr`时，程序不会等到运行阶段崩溃，而是在编译器阶段就出现错误。
- 使用引用计数的shared_ptr是绝对稳定安全。

```cpp
// auto_ptr 会在运行阶段出现 segmentation fault (core dumped)
auto_ptr<string> p1 (new string("auto"));
auto_ptr<string p2>;
p2 = p1; // p2会接管string对象的所有权后，p1的所有权会被剥夺

// unique_ptr 会在编译阶段出现 segmentation fault (core dumped)
unique_ptr<string> p3 (new string("unique"));
unique_ptr<string p4>;
p4 = p3;
```

所以 `unique_ptr` 相对比 `auto_ptr` 更加安全。可以直接就在编译阶段解决在运行阶段会出现的潜在问题。

⚠️ **`重要的注意点`**：

- 使用`new分配内存`时，才能使用`auto_ptr`和`shared_ptr`，使用`new[ ]分配内存`时，`不能使用`它们；
- `不使用new`分配内存时，不能使用`auto_ptr`或`shared_ptr`；
- `不使用new`或`new[ ]`分配内存时，不能使用`unique_ptr`。

`unique_ptr` 可以用于数组的变体。

#### 2.3 如何选择智能指针？

- **`unique_ptr`**：程序`不需要`多个指向同一个对象的指针。
  - 如果编译器没有`unique_ptr`，可以使用 `Boost库` 中的`scoped_ptr`。
- **`shared_ptr`**：程序`需要`使用多个指向同一个对象的指针。
  - 指针数组中使用辅助指针来标识特定的元素。
  - 两个对象包含都指向第三个对象的指针
  - STL容器包含指针
  - 如果编译中没有`shared_ptr`，可使用`Boost库`提供的`shared_ptr`。
- **`auto_ptr`**：在满足`unique_ptr`要求的条件时，也可使用`auto_ptr`，但`unique_ptr`是更好的选择。

### 3. 标准模板库

STL提供的模板

- 容器：一个与数组类似的单元，可以存储若干个值。STL容器是同质，即`存储的值的类型相同`。
- 迭代器：用来`遍历容器的对象`，与可遍历数组的指针类似，是`广义指针`。
- 函数对象：类似`函数对象`，可以是`类对象`或者`函数指针`。
- 算法：完成`特定任务`处方。

#### 3.1 模版类vector

STL通过在头文件vector中定义了vector模板，使其类成为通用的。

创建vector模板对象，使用通常的 <type> 表示法来指出要使用的类型。vector模板使用动态内存分配，所以可以用初始化参数来指出多少矢量。

```cpp
#include <vector>
vector<int> rating(5);
int n;
cin >> n;
vector<double> scores(n);
```  

使用 `[] 运算符`来访问 vector元素。

#### 3.2 可对vector执行的操作

- `size()`：返回容器中元素数目
- `swap()`：交换两个容器的内容
- `begin()`：返回一个指向容器中第一个元素的迭代器
- `end()`：返回一个表示超过容器尾的迭代器。

迭代器：一个广义指针。每个容器类都定义了一个合适的迭代器，迭代器的类型为：iterator 的 typedef，其作用域为整个类。

声明一个迭代器变量的语法如下：

```cpp
vector<double>::iterator pd; // pd 是迭代器
vector<double> scores;
// 迭代器的可进行的两个操作
pd = scores.begin();
*pd = 22.3; // 使用 * 来解引用
++pd;       // 使用 ++ 使得指针指向下一个元素
```

- `push_back()`：将元素添加到vector结尾。
- `erase()`：删除vector中给定区间的元素。
  - 接受两个参数：
    - 起始位置
    - 终点位置
  - 区间为左闭右开。
- `insert()`：插入元素
  - 接受3个参数
    - 指定新元素的插入位置
    - 第二个和第三个为被插入区间。

#### 3.3 STL对vecotr的其它操作

STL从更广泛的角度定义了`非成员函数`来执行这些操作，即不是为了每个容器而定义一个`find()成员函数`，而是定义了一个适用于`所有容器类`的`非成员函数find()`。这种设计理念省去了大量重复的工作。

3个具有代表性的STL函数：

- `for_each()`
  - 可用于很多个容器类，接受3个参数：
    - 前两个是定义容器中`区间的迭代器`
    - 最后一个`指向函数的指针`，普遍一般说最后一个参数是`函数对象`。
  - `for_each()` 函数将被指向的函数用于`容器区间中的各个元素`
  - 被指向的函数`不能修改容器元素的值`
  - 可以使用 `for_each()` 函数来代替 `for循环`。

  ```cpp
  #include<vector>
  struct Review{
    std::string title;
    int rating;
  };
  vector<Review> book;
  vector<Review>::iterator pr;
  vector<Review>::iterator pr;
  for (pr = books.begin(); pr != books.end();pr++)
    ShowReview(*pr);

  // 使用for_each修改为：
  for_each(books.begin(),books.end*()); // 可以避免显式地使用迭代器变量
  ```

- `random_shuffle()`
  - 接受两个指定区间的迭代器参数，并随机排列区间中的元素。

    ```cpp
    random_shuffle(books.begin(),books.end());
    ```

  - 要求容器类允许随机访问，例如vector类。

- `sort()`
  - 也要求容器支持随机访问。
  - 函数的两个版本：
    - 版本1:接受2个定义区间的迭代器参数，并使用为存储在容器中的类型元素定义的`<运算符`，对区间中元素进行操作。

      ```cpp
      // 使用内置的<运算符
      vector<int> coolstuff;
      ...
      sort(coolstuff.begin(),coolstuff.end());
      // 如果容器元素是用户定义的对象，则必须定义能够处理该类型对象的 operator<() 函数
      bool operator<(const Review &r1 , const Review & r2)
      {
        if (r1.title < r2.tile)
          return true;
        else if (r1.title == r2.title && r1.rating < r2.rating)
          return true;
        else
          return true;
      }
      ```

    - 版本2:接受3个参数
      - 前两个参数：指定区间的迭代器
      - 最后一个参数：指向要使用的函数的指针（函数对象）。

### 4. 泛型编程

STL是一种 **`泛型编程（generic programming）`**。

`面向对象编程`关注`编程的数据方面`。`泛型编程`关注`算法`。共同点：抽象和创建可重用代码。

泛型编程旨在编写独立于数据类型的代码。

在C++中，完成通用程序的工具是`模板`。

#### 4.1 为何使用迭代器？

模板提供了存储在容器中的`数据类型的通用表示`，因此还需要遍历容器中的`值的通用表示`，`迭代器`正是这样的通用表示。

- 迭代器应具备的特征：
  - 能进行`解除引用`的操作，以便能够`访问`它引用的值。
  - 迭代器之间能`赋值`。
  - 迭代器之间能`比较`，判断是否相等。
  - 能`遍历`容器中的所有元素，以便于实现 `++` 需求。

```cpp
struct Node{
  double item;
  Node *p_next;
};

class iterator
{
  Node *pt;
  public:
    iterator() : pt(0) {};
    iterator (Node *pn) : pt(pn) {}
    double operator*()= {return pt->item;}
    iterator & operator++() // 前缀++
    {
      pt = pt->p_next;
      return *this;
    }
    iterator operator++(int) // 后缀++
    {
      iterator tmp = *this;
      pt = pt->p_next;
      return tmp;
    }
    ...
};
```

作为一种编程风格，最好避免直接使用迭代器，应尽可能使用STL函数（如for_each()）来处理细节。也可以使用C++11新增的基于范围的for循环。

```cpp
for (auto x : scores) cout << x << std::endl;
```

#### 4.2 迭代器的类型

不同的算法对迭代器的要求也不同。

- 查找算法
  - 需要定义`++运算符`，以便迭代器能`遍历`整个容器。
  - 要求能`读取`数据，但`不要求能写`数据。
- 排序算法
  - 能够`随机访问`，便于`交换`两个不相邻的元素。
  - 如果`iter`是`迭代器`，则可以通过定义`+运算符`来实现随机访问。

STL定义了5种迭代器

- **`输入迭代器`**
  - 被程序用来读取容器中的信息
  - 能访问容器中所有的值，通过支持`++运算符`来实现。
  - `单向`通行，`只读`算法

- **`输出迭代器`**
  - 将信息从程序传输给容器的迭代器，因此`程序的输出`就是`容器的输入`。
  - `单向`通行，`只写`算法

- **`正向迭代器`**
  - 只使用 `++运算符`来遍历容器，每次沿容器向前移动一个元素。
  - `可读可写`，如果要使得`只读`，可使用 `const关键字`。
  
- **`双向迭代器`**
  - 典型函数：`reverse()` 翻转操作
  - 具备`正向迭代器`的`所有特性`。
  - 支持两种（前缀和后缀）递减运算符

- **`随机访问迭代器`**
  - 有些算法（如标准排序和二分检索）要求能够直接跳到容器中的任何一个元素，这叫随机访问，需要随机访问迭代器。
  - 具备双向迭代器的所有特性。

5种迭代器可执行`解除引用操作`（已定义`*运算符`），可进行`比较`（看是否相等，使用了`==运算符`）

#### 4.3 迭代器的层次结构

由于迭代器之间都是后者支持了前者的全部功能，也有自己的功能，所以对应的层次结构可表示为：

![](/assets/images/2022-10-27-10-40-27.png)

每个容器类都定义一个类级 `typedef名称` --- `iterator`，因此 `vector<int>类`的迭代器类型为 `vector<int>::interator`。

#### 4.4 概念、改进和模型

概念可以具有类似继承的关系。概念的具体实现叫做 **`模型（model）`**。指向int的常规指针是一个`随机访问迭代器模型`，也是一个`正向迭代器模型`，因为它满足该概念的所有要求。

##### 4.4.1 将指针用作迭代器

- 迭代器是广义指针，而指针满足所有的迭代器要求。
- 迭代器是STL算法的接口，而指针是迭代器，因此，STL算法可以使用指针来对基于指针的非STL容器进行操作。

STL sort() 函数接受指向容器第一个元素的迭代器和指向超尾的迭代器作为参数。

```cpp
const int SIZE = 100;
double Receipts[SIZE];
sort(Receipts, Receipts + SIZE); // 等价于 sort(&Receipts[0],&Receipts[SIZE])
```

`copy()` ： 将数据从一个容器复制到另一个容器中，通过迭代器的方式实现。

- 前两个参数是要赋值的范围（输入迭代器），最后一个参数是要复制到的位置（输出迭代器）。
- ~~不能使用 `copy`将数据放到`空vector`中~~。

如果有一个表示`输出流`的`迭代器`，可以用`copy()`。STL为模板提供了 ostream_iterator模板。

 **`适配器（adapter）`** ---- **`一个类或函数`**。`适配器`的作用：将一些接口转换为STL使用的接口：可以通过包含`头文件<iterator>` 来实现。

- ostream_iterator 适配器

  ```cpp
  #include <iterator>
  ...
  // 第一个参数：int 指出被发送给输出流的数据类型
  // 第二个参数：char 指出了输出流使用的字符类型。
  // out_iter中的第一个参数：要使用的输出流
  // out_iter中的第二个参数：分隔符
  ostream_iterator<int, char> out_iter(cout," ");
  // out_iter 是一个接口

  // 使用解引用的方式对迭代器进行操作
  *out_iter++ = 15; // 相当于 cout << 15 << " ";
  ```

- istream_iterator

  ```cpp
  // 使用两个 istream_iterator 对象来定义 copy() 的输入范围
  copy(istream_iterator<int,char>(cin),
      istream_iterator<int,char>(),dice.degin());
  // 第一个参数：指出要读取的数据类型
  // 第二个参数：指出输入流使用的字符类型
  ```

##### 4.4.2 其它迭代器

除了 **`istream_iterator`**、**`ostream_iterator`** 之外，还有一些专用的预定义迭代器类型。

- **`reverse_iterator`**：执行递增操作将导致它被递减。
  - 只能允许用于尾部快速插入的容器
- **`back_insert_iterator`**：将元素插入到容器尾部
- **`front_insert_iterator`**：将元素插入到容器的前端
  - 只能用于允许在起始位置做时间固定插入的容器类型。
- **`insert_iterator`**：将元素插入到 insert_iterator 构造函数的参数指定的位置前面。
  - 无限制

后三种（**`back_insert_iterator`**、**`front_insert_iterator`**、**`insert_iterator`**）通过将复制转换为插入来解决不知道长度或者不覆盖已有内容的问题。原因：只做插入新元素的操作，所以不会覆盖已有数据，并使用自动内存分配来确保可以容纳新的数据信息。

```cpp
back_insert_iterator<vector<int> > back_iter(dice);
insert_iterator<vector<int> > insert_iter(dice,dice.begin() );
```

示例：

```cpp
#include <iostream>
#include <string>
#include <iterator>
#include <vector>
#include <algorithm>

void output(const std::string & a) {std::cout << s << " ";}

int main()
{
  using namespace std;
  string s1[4] = {"fine","fish","fashion","fate"};
  string s2[2] = {"busy","bate"};
  string s3[2] = {"silly","singer"};
  vector <string> words(4);
  copy(s1,s1 + 4,words.begin()); // 将s1中的4个字符串复制到words中
  for_each(words.begin(),words.end(),output);
  cout << endl;
  // 构造匿名对象 back_insert_iterator
  // 将s2的元素插入到末尾，而且words的长度扩增到6个元素
  copy(s2,s2+2,back_insert_iterator<vector<string> (words)>);
  for_each(word.begin(),words.end(),output);
  cout << endl;
  // 构造 匿名对象 insert_iterator
  // 将s3中的元素插入到words第一个元素的前面，words的长度被增加到8个元素
  copy(s3,s3+2,insert_iterator<vector<string> >(words,words.begin()));
  for_each(words.begin(),words.end(),output);
  cout << endl;
  return 0;
}
```

#### 4.5 容器种类

STL具有容器概念和容器类型。

概念是具有名称（如容器、序列容器、关联容器等）的通用类别。

##### 4.5.1 容器类型

- 可用于创建具体容器对象的模板。
- C++11 之前有11个
  
  deque、list、queue、priority_queue、stack、vector、map、multimap、set、multiset和bitset

- C++11中新增5个

  forward_list、unordered_map、unordered_multimap、unordered_set 和 unordered_multiset

##### 4.5.2 容器概念

容器概念指定了所有STL容器类都必须满足的一系列要求。

- 容器是存储其他对象的对象。被存储的对象必须是`同一种类型`的，可以是`OOP意义上的对象`，也可以是`内置类型值`。

- 存储在容器中的基本类型必须满足：是`可复制构造`和`可赋值`的。
- 只要类定义没有将可复制构造函数和赋值运算符声明为私有或保护的。

“复杂度”：描述了执行操作所需的时间。

- 编译时间：在编译时执行，执行时间为0
- 固定时间：发生在运行阶段，但独立于对象中的数目
- 线性时间：时间与元素数目成正比。

##### 4.5.3 `序列（sequence）`容 器

7种STL容器类型：`deque`、`C++11新增的forward_list`、`list`、`queue`、`priority_queue`、`stack`和`vector` 都是序列。

**`队列`** 可以在 **`队尾添加`** 元素，在 **`队首删除`** 元素。

**`deque`** 表示的 **`双端队列`** 允许在 **`两端添加和删除`** 元素。

序列要求其元素按严格的线性顺序排列，即存在第一个元素、最后一个元素、除第一个元素和最后一个元素外，每个元素前后都有一个元素。

数组和链表是序列，但是分支结构不是。

对于序列，都支持以下的操作：

![](/assets/images/2022-10-27-10-40-47.png)

在情况允许下，复杂都是固定时间。

- vector
  - 模板头文件 `vector`
  - 是数组的一种类表示
  - 提供`自动内存管理`概念，可以`动态改变vector对象的长`度，随着元素的添加和删除而增大和减小。
  - 在`尾部`复杂度是：`固定时间`
  - 在`头部`或`中间`复杂度：`线性时间`
  - 支持`可反转容器（reversible container）`的两个类方法
    - **`rbegin()`**：返回一个指向反转序列的第一个元素的迭代器
    - **`rend()`**：返回反转序列的超尾迭代器
    - 强调随机快速访问

- deque
  - 模板头文件 `deque`
  - 双端队列（double-ended queue）
  - 在STL中，类似vector，支持随机访问。
  - 一般发生在起始和结尾处的操作，考虑使用deque

- list
  - 模板头文件 `list`
  - `双向链表`
  - list在链表中任一位置进行插入和删除的复杂度都固定
  - 元素的`快速插入`和`删除`
  - list不支持数组表示法和随机访问
  - `sort()`、`merge()`、`unique()` 和 `remove()`方法

- forward_list（C++11）
  - 实现了`单链表`
  - 单链表的特点：每个节点都只链接到下一个节点，而没有链接到前一个节点。
  - 是一个正向迭代器

- queue
  - 模板头文件 `queue`
  - 是一个`适配器类`
  - **不允许随机访问队列元素，不允许遍历队列**
  - 使用限制在定义队列的基本操作上，可以将元素进行如下操作：
    - 添加到队尾
    - 从队首删除元素
    - 查看队首和队尾的值
    - 检查元素数目
    - 测试队列是否为空

- priority_queue
  - 模板头文件 `queue`
  - 是一个`适配器类`
  - 与queue主要区别： 在priority_queue中，最大元素被移到队首，内部区别在于，默认的底层是 vector
  - 可修改用于确定哪个元素放到队首的比较方法

    ```cpp
    priority_queue<int> pq1; // 使用priority_queue默认方式 排序
    priority_queue<int> pq2(greater<int>) // 使用greater<int> 排序
    ```

- stack
  - 头文件 `stack`
  - 是一个适配器类
  - 不允许随机访问栈元素，也不能遍历栈。
  - 基本操作和queue类似。

#### 4.6 关联容器（associative container）

关联容器是对容器概念的另一个改进。

关联容器将值与键关联在一起，并使用`键来查找值`。

优点：提供对元素的快速访问。允许插入新元素，但`不能指定插入的位置`。关联容器通常是用于确定数据放置的算法。

基于`树（数据结构）`来实现。

树的概念：其根节点链接到一个或两个节点，节点再次分支。

STL提供4种关联容器

- 头文件 set
  - set
    - set的类型与键相同，且键唯一。不会有相同的元素，对于set来说，值就是键。
  - multiset
    - 类似set，一个键可能有多个值。
- 头文件 map
  - map
    - 值与键的类型不同，键是唯一的
    - 每一个键只对应于一个值。
  - multimap
    - 类似map，一个键可与多个值相关联。

#### 4.7 无序关联容器（C++11）

无序关联容器是对容器概念的另一种改进。

关联容器基于树结构实现，而无序关联容器是基于数据结构哈希表来实现。旨在提高添加和删除元素的速度以及提高查找算法的效率。

4种无序关联容器：

- unordered_set
- unordered_multiset
- unordered_map
- unordered_multimap

### 5. 函数对象

很多STL算法都使用函数对象 ---- 也叫 **`函数符（functor）`**。

函数符是可以以函数方式与`()` 结合使用任意对象：`函数名`、`指向函数的指针`和`重载了()运算符的类对象`（即定义了`函数operator()()的类`）

在for_each方法中，第三个参数不能声明函数指针，所以for_each 模板原型为：

```cpp
template<class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function f);
```

#### 5.1 函数符概念

STL定义了容器和迭代器的概念，也定义了函数符的概念

- 生成器（generator）是不用参数即可调用的函数符。
- 一元函数（unary function）是用一个参数可以调用的函数符
- 二元函数（binary function）是用两个参数可以调用的函数符
- 返回bool值的一元函数是谓词（predicate）
- 返回bool值的二元函数是二元谓词（binary predicate）。

#### 5.2 预定义的函数符

STL定义了多个基本函数，它们执行诸如两个值相加、比较两个值是否相等的操作。提供这些函数对象是为了支持将函数作为参数的STL函数。

头文件 `functional` 定义了多个模板类函数对象，其中包括了 `plus>()`。

```cpp
#include <functional>
...
plus<double> add; // 创建一个 plus<double> 对象
double y = add(2.2,3.4); //使用 plus<double>::operator()()
```

#### 5.3 自适应函数符号和函数适配器

函数符成为自适应的原因：携带标识参数类型和返回类型的`typedef成员`。这些成员是：

- result_type
- first_argument_type
- second_argument_type

函数符自适应的意义在于：函数适配器对象可以使用函数对象，并认为存在这些typedef成员。

### 6. 算法

STL包含很多处理容器的非成员函数。

- sort()
- copy()
- find()
- random_shuffle()
- set_union()
- set_intersection()
- set_difference()
- transform()

**`整体设计思想`**：都使用  **`迭代器来标识要处理的数据区间和结果的放置位置`**。

对于算法函数设计：

- 都使用`模板来提供泛型`
- 都使用`迭代器`来提供`访问容器中数据的通用表示`

#### 6.1 算法组

STL将算法库分成4组：

- 头文件 `algorithm`
  - **`非修改式序列操作`**
    - 对区间中的每个元素进行操作。操作`不修改`容器的内容。
    - 如`find()` 和 `for_each()`
  - **`修改式序列操作`**
    - 对区间中的每个元素进行操作。
    - 可`修改`容器内容（包括修改值、修改值的排列顺序）
    - 如 `transform()`、`random_shuffle()`、`copy()`
  - **`排序和相关操作`**
    - 包含多个排序函数和其它各种函数，包括集合操作
    - 如 sort()
- 头文件 `numeric`
  - **`通用数字运算`**
    - 包括将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数。
    - 一般是数据的操作特性。

#### 6.2 算法的通用特征

对算法分类的方式之一就是按结果放置的位置来进行分类。

有些算法有两个版本：

- `就地`版本
  - `sort()` 函数完成时，将结果存放到原始数据的位置上
- `复制`版本
  - copy() 函数将结果发送到另一个位置

transform() 可以是两个版本。

STL中约定：复制版本的名称将以 `_copy()` 来结尾。复制版本接受一个额外的输出迭代参数，参数指定结果的放置位置。

#### 6.3 STL和string类

string类虽不是STL的组成部分，但是设计string时考虑到了STL。其中的`begin()`、`rbegin()`、`end()` 和 `rend()` 等成员函数，都可以使用STL接口。

#### 6.4 函数和容器方法

有时可以选择使用STL方法或者STL函数，通常方法是更好的选择。

1. 方法适合于特定的容器
2. 方法作为成员函数，它可以使用模板类的内存管理工具，从而调整容器的长度。

例如，假设是数字组成链表，要删除特定值的所有实例

```cpp
la.remove(4); // 删除值为4的所有元素，删除后链表的长度也会被自动调整
```

尽管方法通常是更适合，但非方法函数更通用。

非方法函数可以用于数组、string对象、STL容器，可用来处理混合的容器类型。

### 7. 其它库

头文件 `complex` 为复数提供了`类模板complex`，包含用于 `float`、`long`和`long double` 的`具体化`。这个类提供了标准的复数运算及能够处理复数的标准函数。

C++11新增的头文件 random 提供了更多的随机数功能。

valarray头文件提供的模板类valarray，类模板被设计用于数值数组，支持各种数值数组操作。

#### 7.1 vector、valarray和array

C++中提供的3个数组：

- vector
- valarray
- array

##### 7.1.1 vector

vector模板类 是一个容器类和算法系统的一部分，支持面向容器的操作。如排序、插入、重新排列、搜索、将数据转移到其它容器中等。

##### 7.1.2 valarray

`valarray类模板`是`面向数值计算`的，但不是STL的一部分。它没有 `push_back()` 和 `insert()` 方法。但为很多数学运算提供了一种简单、直观的接口。

假设要计算数组中每个元素的自然对数，并将计算结果存储到另一个数组的相应元素中，STL方法如下：

```cpp
transform(ved1.begin(),ved1.end(),ved3.begin(),log);
```

valarray类重载了数学函数，使之接受一个valarray参数，并返回一个valarray对象，所以可以：

```cpp
ved3 = log(ved1); // log() 重载
```

也可以使用 apply() 方法，适用于非重载函数：

```cpp
ved3 = ved1.apply(log);
```

`valarray` 类提供了方法：

- `sum()`：计算valarray对象中所有元素的和
- `size()`：返回元素数
- `max()`：返回最大的元素值
- `min()`：返回最小的元素值

C++11提供了接受valarray对象作为参数的模板函数 `begin()` 和 `end()`。

```cpp
sort(begin(vad),end(vad)); // C++11 fix
```

##### 7.1.3 array

array 为替代数组而设计，通过提供更好、更安全的接口，让数组效率更高。

Array表示长度固定的数组，它不支持`push_back()` 和 `insert()`，但提供了STL方法，包括`begin()`、`end()`、`rbegin()` 和 `rend()` 。

#### 7.2 模板initializer_list（C++11）

头文件 `initializer_list`

模板`initializer_list`是C++11新增。如果类有接受`initializer_list`作为参数的`构造函数`，一般使用表示法 `{ }` 而不是 `()` 来调用`类构造函数`。

```cpp
shared_ptr<double> pd = {new double}; // 使用 {} 来代替 ()

// 所有的initializer_list 元素的类型都必须相同，如果不相同，编译会进行必要的转换
std::vector<double> payments {45.99,39.23,19,89}; 
// 其中的 19和89 会被转换成double类型,不能隐式的窄化转换（double不能转换为int）
std::vector<double> payments {45.99,39.23,19.0,89.0};
```

[代码实例](initializer_list.cpp)

可按`值传递` initializer_list 对象，也可按`引用传递`。

## 第十七章 输入、输出和文件

### 1. C++输入和输出概述

C实现自带了一个标准函数库，C++自带了一个标准类库。标准类库是一个非正式的标准，是由头文件 `iostream` 和 `fstream` 中定义的类组成。

#### 1.1 流、缓冲区和`iostream`

C++程序把`输入`和`输出`看作字节流。

- 输入时
  - 程序从`输入流`中抽取`字节`
- 输出时
  - 程序把`字节`插入到`输出流`中

输入流中的字节可能来自键盘、存储设备或者其它程序。

输出流中的字节可以流向屏幕、打印机、存储设备或者其它程序。

管理输入包含两步：

- 将流与输入去向的程序关联起来
- 将流与文件连接起来。

通常，通过使用缓冲区可以高效地处理输入和输出。**`缓冲区是用作中介的内存块`** 。它将信息从设备传输到程序或从程序传输给设备的 **`临时存储工具`**。

头文件iostream 中包含了一些专门设计用来实现管理流和缓冲区的类。

- streambuf类 为缓冲区提供了内存，并提供了用于填充缓冲区，访问缓冲区内容，刷新缓冲区和管理缓冲区内存的类方法。
- ios_base类 表示流的一般特征，如是否可读取，是二进制还是文本流等。
- ios类基于ios_base，其中包含了一个指向streambuf对象的指针成员。
- ostream类 是基于ios类派生而来，提供输出方法。
- istream类 也是基于ios类派生而来，提供输入方法。
- iostream是基于 istream 和 ostream类，基础了输入和输出方法。

在程序中包含 iostream 文件，将自动创建8个流对象（4个用于窄字符流，4个用于宽字符流）

- 处理窄字符流 ----- 处理 char_t 类型
  - `cin对象`对应于标准输入流。
  - `cout对象`与标准输出流相对应。
  - `cerr对象`与标准错误流相对应，用于显示错误信息。流不会被缓冲。
  - `clog对象`对应标准错误流。流会被缓冲。

- 处理宽字符流 ----- 处理 wchar_t 类型
  - wcin对象
  - wcout对象
  - wcerr对象
  - wclog对象

#### 1.2 重定向

标准输入和输出流通常连接键盘和屏幕。

- **`输入重定向（<）`**
- **`输出重定向（>）`**

### 2. 使用cout进行输出

C++将输出流看作字节流。平台不同，则读取字节流会有差异。

ostream类最重要的任务之一：将`数据内部表示（二进制位模式）`转换为由`字符字节`组成的输出流，使能够直接翻译成二进制数据。

在C++中，`<< 运算符`的默认含义是`按位左移`运算符。但ostream类重新定义了 << 运算符，方法将其重载为输出（也称为 **`插入运算符`**）。

插入运算符的所有化身的返回类型都是 `ostream&`。原型格式如下：

```cpp
ostream & operator<<(type);
```

除了 operator<<() 函数外，ostream类还提供 `put()` 方法和 `write()` 方法。前者用于显示`字符`，后者用于显示`字符串`。

- `put()`方法
  - 原型如下：

    ```cpp
    // 参数：提供要显示的字符
    ostream &put(char);
    ```

- `write()`方法
  - 原型如下：

    ```cpp
    // 第一个参数：提供要显示字符串的地址
    // 第二个参数：指出要显示多少个字符
    basic_ostream<charT, traits> & write(const char_type* s, streamsize n);
    ```

  - ⚠️注意点：write() 方法不会在遇到空字符时自动停止打印字符，而只是打印指定数目的字符，即使超出字符串的边界。

都是类成员函数，需要有调用对象

```cpp
cout.put('w');
cout.write("Kansas",6);
```

`ostream类`对`cout对象`处理的输出进行`缓冲`，所以输出不会立即发送到目标地址，而是被存储到缓冲区中，直到缓冲区填满。然后程序将刷新缓冲区，把内容发送出去，并清空缓冲区，以存储新的数据。

如果实现不能在所希望时刷新输出，可以使用强制刷新的两个控制符之一：

- `flush`：刷新缓冲区
- `endl`：刷新缓冲区，并插入一个换行符

```cpp
cout << "Hello, good-looking !" << flush;
cout << "Wait just a moment, please ." << endl;
```

ostream插入运算符将值转换为文本格式。在默认情况下，格式化值的方式如下：

- `char值`：如果代表的是可打印字符，则将被作为一个字符显示在宽度为一个字符的字段中。
- `数值整型`：将以十进制方式显示在一个刚好容纳该数字的字段中。
- `字符串`：显示在宽度等于该字符串长度的字段中
- `浮点类型`：浮点类型被显示为6位，末尾的0不显示
  - 数字以`定点表示法`显示还是`科学计数法`表示，取决于值。
  - 当指数大雨6或者小于等于-5时，将使用科学计数法。
  - `字段宽度`恰好容纳`数字`和`负号`。

#### 2.1 修改显示时使用的计数系统

ostream类从ios类派生而来，而ios从ios_base类派生而来。ios_base类存储了描述格式状态的信息。

通过使用 ios_base 的成员函数，可以控制字段和小数位数。。因ios_base类时ostream的间接基类，可以将其方法用于ostream对象。

要控制整数以`十进制`、`十六进制`还是`八进制`显示，可以使用 `dec`、`hex` 和 `oct` 控制符。

```cpp
dec(cout);   // 十进制，等价于  cout << dec;
hex(cout);   // 十六进制，等价于 cout << hex;
oct(cout);   // 八进制，等价于 cout << oct;
```

使用上述设置后，程序将以十六进制形式打印整数值，直到将格式状态设置为其它选项为止。注意：控制符不是成员函数，不必通过对象来调用。

#### 2.2 调整字段宽度

由于数字的字段宽度不同，所以可以使用 `width 成员函数`将长度不同的数字放到宽度相同的字段中。方法原型为：

```cpp
int width(); // 返回字段宽度的当前设置
int width(int i); // 将字段宽度设置为 i 个空格，并返回以前的字段宽度值
```

`width()`方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值。

C++永远不会`截短`数据，会`增宽`字段，以`容纳`该数据。**`C/C++的原则`** ：显示所有的数据比保持列的整洁更重要，C++视`内容重于形式`。

```cpp
int main()
{
  cout.width(5);
  cout << "N" << ":";
}
```

#### 2.3 填充字符

在默认情况下，`cout` 使用`空格填充`字段中`未被使用的部分`，可以使用 `fill()` 成员函数来改变填充字符。

```cpp
cout.fill('*');
```

对于检查结果，防止接收方添加数字很有用。

#### 2.4 设置浮点数的显示精度

`浮点数精度`的含义取决于`输出模式`。在默认模式下，指的是显示的总位数。

在定点模式和科学模式下，`精度`指的是`小数点后的位数`。

C++中的默认精度为`6位`（末尾的0将不显示），`precision()` 成员函数使能够选择其他值。

```cpp
cout.precision(2); // 设置精度为2，设置后一直有效，只有重新设置会被重置
```

#### 2.5 打印末尾的0或小数点

使用 `setf()` 函数，能够控制多种格式化特性：

```cpp
cout.setf(ios_base::showpoint); // 默认精度是6位
```

使用默认的浮点格式时，会将导致末尾的0被显示出来。

#### 2.6 setf()

ios_base类有一个受保护的数据成员，其中的各位分别控制着格式化的各个方面。

对于setf() 函数，有两个原型：

```cpp
// 此为原型1
fmtflags setf(fmtflags);
```

`fmtflags` 是 `bitmask类型`的`typedef名`，用于存储格式标记。

其中ios_base定义了代表位置的常量，其中一些定义为：

![](/assets/images/2022-10-27-10-43-59.png)

> 因都是 ios_base类中定义，所以使用时，必须加上`作用域解析运算符`。

`bitmask` 类型是一种用来存储各个位值的类型。可以是整型、枚举，也可以是STL bitset容器。

在C++标准中，定点表示法和科学表示法都有两个特征：

- 精度指的是小数位数，而不是总位数
- 显示末尾的0

第二种 `setf()` 函数的原型：

```cpp
// 第一个参数：包含所需设置的fmtflags值
// 第二个参数：指出要清除第一个参数中的那些位
fmtflags setf(fmtflags,fmtflags);
```

例如，要左对齐，则使用：

```cpp
ios_base::fmtflags old = cout::setf(ios::left, ios::adjustfield);
```

如果要恢复以前的设置，则使用，

```cpp
cout.setf(old,ios::adjustfield);
```

在调用setf() 后可以通过unsetf() 来消除，unsetf() 的原型如下：

```cpp
// mask 是位模式，mask中是所有的位都设置为1，将使得对应的位被复位
void unsetf(fmtflags mask);
```

[实际代码示例](./setf2.cpp)

#### 2.7 头文件iomanip

C++ 在头文件 `iomanip`中提供了一些控制符。其中3个最常用的控制符分别是：

- `setprecision()`：设置精度
  - 接受一个指定精度的整数参数

- `setfill()`：填充字符
  - 接受一个指定填充字符的char参数

- `setw()`：字符宽度
  - 接受一个指定字段宽度的整数参数

### 3. 使用cin进行输入

cin对象将标准输入表示为字节流，通常情况下，通过键盘来生成这种字符流。

#### 3.1 `cin>>`如何检查输入

不同版本的抽取运算符查看输入流的方法都是相同的。他们跳过`空白（空格、换行符和制表符）`，直到遇到`非空白字符`。

- 单字符模式
  - `>>` 运算符将读取该字符，将它放置到指定的位置
- 其他模式
  - `>>` 运算符将读取一个指定类型的数据。

#### 3.2 流状态

流状态（被定义为isolate类型，而isolate是一种bitmask类型）。由3个ios_base元素组成：

- `eofbit`：表示到达文件末尾
- `badbit`：遇到无法诊断的失败破坏流
- `failbit`：未能读取到预期的字符

其中的每个元素都是一位，可以是`1（设置）`或`0（清除）`。当3个状态位都被设置为0时，说明一切顺利。

![](/assets/images/2022-10-27-10-44-18.png)

`clear()` 和 `setstate()` 类型，都是重置状态，但采取的方式不同。

- `clear()`：将状态设置为它的参数
- `setstate()`：只影响其参数中设置的位置，而不会影响其他位。

exceptions() 方法返回一个位字段，包含3位，分别对应于`eofbit`、`failbit`、`badbit`。修改流状态涉及`clear()` 或 `setstate()` ，都将使用`clear()`。当前状态中的对应位也被设置，则`clear()` 将引发 `ios_base::failure` 异常。如果两个值都设置了`badbit`，将发生这种情况。

`exceptions()` 的默认设置为 `goodbit`，没有引发异常，但重载的 `exceptions(isolate)` 函数使得能够控制其行为。

```cpp
cin.exceptions(badbit);
```

位运算符OR 使能够指定多位。

```cpp
cin.exceptions(badbit | eofbit);
```

设置流状态位将对后面的输入或者输出关闭，直到位将被清除。

```cpp
while (cin >> input)
{
  sum += input;
}
// 可以在此处增加 clear() 来清除流状态
//cout.clear();
cin >> input; // don't work
```

如果希望程序在流状态位被设置后能够读取后面的输入，就必须将流状态设置为良好。可以通过调用 `clear()` 来实现。导致输入循环终止的不匹配输入仍留在输入队列中，程序必须跳过它。

#### 3.3 其他istream类方法

- 方法`get(char&)` 和 `get(void)` 提供不跳过空白的单个字符输入功能
- 函数 `get(char*, int, char)` 和 `getline(char*, int, char)`在默认情况下读取整行而不是一个单词。

都称为 **`非格式化输入函数`**。都只是读取字符输入，而不会跳过空白，也不进行数据转换。

![](/assets/images/2022-10-27-10-45-45.png)

对于 `>>`、`get(char &)` 或者 `get(void)`的选择问题上，确定`是否跳过空格`，如果跳过空白则使用`抽取运算符>>`。

`get()` 方法会检查程序每个字符。

对于字符串的输入成员函数，getline() 成员函数和 get() 的字符串读取版本都读取字符串，他们的函数特征标相同。

```cpp
// 第一个参数：放置输入字符串的内存单元的地址
// 第二个参数：比要读取的最大字符数大1
// 第三个参数：指定用做分界符的字符
istream & get(char *, int, char);
istream & get(char *, int);
istream & getline(char *, int, char);
istream & getline(char *, int);
```

对于get() 和 getline() 方法的区别：

- `get()`：将换行符留在输入流中
- `getline()`：抽取并丢弃输入流中的换行符。

特殊的成员函数 `ignore()`，函数原型表示：

```cpp
istream & ignore(int = 1,int = EOF); // 原型中的两个参数提供的默认值为 1 和 EOF。
```

默认参数值EOF导致 `ignore()` 读取指定数目的字符或读取文件尾。

![](/assets/images/2022-10-27-10-46-04.png)

#### 3.4 其他istream方法

- `read()`：读取指定数目的字节，并将其存储在指定的位置中。不会在输入后加上空值字符。
- `peek()`：返回输入中的下一个字符，但不抽取输入流中的字符。
- `gcount()`：返回最后一个非格式化抽取方法读取的字符数。
- `putback()`：将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符。

### 4. 文件输入和输出

C++ I/O类软件包处理文件输入和输出的方式与处理标准输入和输出的方式相似。

- 要写入文件，需要创建一个`ofstream对象`，并使用`ofstream方法`。
- 要读取文件，需要创建一个`ifstream对象`，并使用`ifstream方法`。

#### 4.1 简单的文件I/O

要让程序`写入文件`的做法：

- 创建一个`ofstream对象`来管理`输出流`
- 将该对象与特定的文件关联起来
- 以使用`cout`的方式使用该对象，唯一的区别是输出将进入文件，而不是屏幕。

`读取文件`的做法：

- 创建一个`ifstream对象`来管理`输入流`
- 将该对象与特定的文件关联起来
- 以使用`cin`的方式使用该对象

当输入和输出`流对象过期（如程序终止）`时，到文件的连接将自动关闭，另外，也可以使用 `close()` 方法来显式地关闭到文件的连接。关闭连接并不会删除流，只是将流重新连接到同一个文件或者另一个文件。

```cpp
ifstream fin;
ofstream fout;
fout.close();
fin.close();
```

#### 4.2 流状态检查和`is_open()`

C++文件流从 `ios_base` 类那里继承了一个流状态成员。

在C++通过使用 `is_open()` 方法 来检查文件是否被成功打开。

#### 4.3 命令行处理技术

文件处理程序通常是使用命令行参数来指定文件。命令行参数是用户在输入命令时，在命令行中输入的参数。

C++中在命令行环境中运行的程序能够访问命令行参数的机制

```cpp
// argc：命令行中的参数个数
// argv：变量为一个指针，指向一个指向char的指针。argv[0] 表示指向一个参数（字符串指针）
int main(int argc, char *argv[])
```

#### 4.4 文件模式

文件模式描述的是`文件将被如何使用`：`读`、`写`、`追加`等。

ios_base类定义了一个 `openmode` 类型，用于表示模式。

![](/assets/images/2022-10-27-10-46-17.png)

位运算符OR`（|）`：将两个位值合并成一个可用于设置两个位的值。

```cpp
ofstream fout("bageis",ios_base::out | ios_base::app);
```

在 `ios_base::out` 本身将导致文件将被截短，但与 `ios_base::in` 一起使用时，不会导致文件被截短，没有列出的组合。

`ios_base::ate` 和 `ios_base::app` 都将文件指针指向打开的文件结尾。区别之处：

- `ios_base::app`：将指针放到文件尾
- `ios_base::ate`：只允许数据添加到文件尾。

数据存储在文件中，是两种形式：

- 文本格式：将所有的内容都存储为文本。
- 二进制格式：将存储值的计算机内部表示。
  - 计算机不是存储字符，而是以二进制的形式存储。

文件两种存储形式的优缺点

- 文本格式
  - 优点
    - 便于读取
    - 使用编辑器或字符处理器来读取和编辑

- 二进制格式
  - 优点
    - 不会有转换误差或者舍入误差
    - 保存速度快，不需要转换
    - 可以大块存储数据。
    - 数据特征不同，空间占用小
  - 缺点
    - 换系统或者OS会导致无法正常使用

要以`二进制格式（而不是文本格式）`存储数据，可以使用 `write()` 成员函数。

将文件使用二进制的格式：

```cpp
fout.write((char *) &pl, sizeof pl)
// 将pl地址强制转换为指向char的指针
// sizeof() 获取字节数
```

要使用文件恢复信息，则使用通过 `ifstream对象` 使用相应的 `read()` 方法：

```cpp
ifstream fin("planets.dat",ios_base::in | ios_base::binary);
fin.read((char *) &pl,sizeof pl);
```

> `read()` 和 `write()` 成员函数的功能是`相反`，一般使用 `read()` 来恢复 `write()` 写入的数据。

#### 4.5 随机存取

随机存取指的是直接移动（不是依次移动）到文件的任何位置。

随机存取常被用于数据库文件，程序维护一个独立的索引文件。文件指出数据在主数据文件中的位置。

需要在一种文件中移动的方式，`ifstream类`继承的两个方法：

- `seekg()`：将`输入指针`移到指定的文件位置。
  - 可用于 `ifstream` 对象
- `seekp()`：将`输出指针`移到指定的文件位置。
  - 可用于 `ofstream`对象

`seekg()` 的原型：

```cpp
basic_istream<charT, traits> & seekg(off_type, ios_base::seekdir);
basic_istream<charT, traits> & seekg(pos_type);

// 将 char 具体化
istream & seekg(streamoff, ios_base::seekdir); // 定位到离第二个参数指定的文件位置特定距离（单位为字节）的位置
istream & seekg(streampos); // 定位到离开文件开头特定距离（单位为字节）的位置
```

[代码示例](./random.cpp)

### 5. 内核格式化

头文件 `sstream` 定义了一个从 `ostream类`派生来的`ostringstream类`。如果创建了一个`ostringstream对象`，则可以将信息写入其中，并将其信息存储。

`istringstream` 和 `ostringstream类`使得能够使用 `istream` 和 `ostream` 类的方法来管理存储在字符串中的字符数据。

## 第十八章 探讨C++新标准

### 1. 复习C++11功能

#### 1.1 新类型

C++11新增类型：

- 整型
  - `long long`
  - `unsigned long long`
- 字符表示
  - `char16_t`
  - `char32_t`

#### 1.2 统一的初始化

C++11 扩大了用大括号起的列表（初始化列表）的适用范围。使其可用于所有`内置类型`和`用户定义类型（即类对象）`。列表初始化的三种方式：

- 使用初始化列表时，可添加`等号（=）`，也可不添加。

  ```cpp
  int x = {5};
  short quar[5] {4,5,6,2,1};
  ```

- 可以用于`new表达式`中

  ```cpp
  int *ar = new int [4] {2,4,6,7}; C++11
  ```

- 创建对象时，可使用`大括号（而不是圆括号）`括起来的列表来调用构造函数。

  ```cpp
  class Stump
  {
    private:
      int roots;
      double weight;
    public:
      Stump(int r,rouble w) : roots(r), weight(w) {}
  };
  Stump s1(3,15.6); // old style
  Stump s2{5,43.4}; // C++11
  Stump s3{4,32.1}; // C++11
  ```

##### 1.2.1 缩窄

- 初始化列表语法可防止缩窄，即禁止将数值赋给无法存储它的数值变量，即将值存储到比它“窄”的变量中。

- 编译器会禁止变窄类型的转换，但允许在范围内变宽的转换。

##### 1.2.2 `std::initializer_list`

- C++11中提供 `initializer_list模板类`，可用作构造函数的参数。

- 如果类有接受 `initializer_list` 作为参数的构造函数，则`初始化列表语法`就只能用于该构造函数。
- 列表中的元素必须是`同一种类型`或者`可转换为同一种类型`。

#### 1.3 声明

##### 1.3.1 `auto`

- `C++11`使用`auto关键字`实现`自动类型推断`。
- 要求进行显式初始化，让编译器能够将变量的类型设置为初始值的类型。

- `auto关键字`也可`简化模板声明`。

##### 1.3.2 `decltype`

- decltype关键字：将变量的类型声明为表达式指定的类型。

  ```cpp
  template <typename T, typename U>
  void ef(T t, U u)
  {
    decltype(T*U) tu;
    ...
  }
  ```

##### 1.3.3 返回类型后置

- C++11新增函数声明语法：在函数名和参数列表后面指定返回类型。

  ```cpp
  double f1(double,int); // 传统方式
  auto f2(double,int)->double; // C++11中的新语法
  ```

- 使用 decltype来指定模板函数的返回类型：
  
  ```cpp
  template<typename T, typename U>
  auto eff(T t, U u) -> decltype(T*U)
  {
    // 当编译器遇到 ef的参数列表时，T和 U不再作用域内，因此必须在参数列表后使用decltype。
    ....
  }
  ```

##### 1.3.4 模板别名：`using`

解决标识符冗长或复杂的问题。

- 早期使用 `typedef`
  - 不能用于模板部分具体化

  ```cpp
  typedef std::vector<std::string>::iterator itType;
  ```

- C++11提供 `using=`
  - 可用于模板部分具体化

  ```cpp
  template <typename T>
  using arr = std::array<T,int>; // 模板部分具体化
  ```

##### 1.3.5 `nullptr`

C++11 新增关键字 `nullptr`来表示`空指针`。它是`指针类型`，~~不能转换为整型类型~~。

为向后兼容，C++11仍允许使用 `0` 来表示空指针，因此表达式 `nullptr==0` 为 `true`。

#### 1.4 智能指针

因为在程序中使用 new 分配内存，未将其及时 delete释放。引入`智能指针auto_ptr`。

C++11抛弃`auto_ptr`，并新增了三种智能指针：`unique_ptr`、`shared_ptr` 和 `weak_ptr`。

#### 1.5 异常规范的修改

指出函数不会引发异常有一定的价值，所以C++11添加了`关键字noexpect`：

```cpp
void f875(short, short) noexpect; // 不会抛出异常
```

#### 1.6 作用域内枚举

在C++11中新增一种枚举。使用 `class` 或者 `struc` t来定义。

```cpp
enum old1 {yes,no,maybe}; // 传统方式
enum class New1 {never,sometimes,often,always}; // 新方式
enum struct New2 {never,lever,sever}; // 新方式
```

新枚举要求进行`显式限定`，以`避免名称冲突`。所以在引用枚举时，则使用

```cpp
New1::never;
New2::never;
```

#### 1.7 对类的修改

- `显式转换运算符`
  - 早期的自动类型转换会导致意外问题，所以在C++11中引入关键字 `explicit`，以禁止`单参数构造函数导致的自动转换`。

- `类内成员初始化`
  - 可使用等号或者大括号版本的初始化，但不能使用圆括号版本的初始化。
  - 类内成员初始化，可避免在构造函数中编写重复的代码。

#### 1.8 模板和STL方面的修改

- 基于范围的for循环

  ```cpp
  double price[5] = {4.99,10.99,6.87,7.99,8.49};
  for (auto x : price)
    std::out << x << std::endl;
  ```

  - 如果要在循环中修改数组或容器中的每个元素，可使用引用类型。

- 新的STL容器
  - C++11新增STL容器：`forward_list`，`unordered_map`，`unordered_multimap`，`unordered_set`，`unordered_multiset`。
  - C++11新增模板array，实例化时，可指定元素类型和固定的元素数。

- 新的STL方法
  - C++11新增STL方法
    - `cbegin()`
    - `cend()`
    - `crbegin()`
    - `crend()`
  - 其中 `crbegin()`、`crend()` 是 `rbegin()`、`rend()` 的`const`版本。
  - 除传统的`复制构造函数`和`常规赋值运算符`外，STL容器还有`移动构造函数`和`移动赋值运算符`。

- valarray升级
  - C++11中添加了两个函数 begin() 和 end()。都接受 valarray 作为参数，并返回迭代器。

- 抛弃export
  - C++98新增
  - C++终止用法，但为了兼容还保留关键字 export。

- 尖括号
  - C++在声明嵌套模板时不再需要使用空格将尖括号分开。

#### 1.9 右值引用

- 左值引用
  - 左值：一个表示数据的表达式，程序可获取其地址。
  - 左值出现在赋值语句的左边，但修饰符的出现const使得声明的标识符，即不能给它赋值，但可获取其地址。

  ```cpp
  int n;
  int * pt = new int;
  const int b = 101; // 不能赋值，
  int & rn = n;
  int & rt = *pt;
  const int &rb = b; // b标识符const引用地址
  ```

- 右值引用
  - C++11新增`右值引用`，使用 `&&` 表示。右值引用可以关联到右值，即可出现在赋值表达式右边，但不能对其应用`地址运算符的值`。
  - `右值`包括：`字面常量`、`表达式`和`返回值的函数`（函数返回的不能是引用）。
  - 引入右值引用的主要目的之一：实现`移动语义`。
  
  ```cpp
  int x = 10;
  int y = 23;
  int && r1 = 13; // 字面常量
  int && r2 = x + y;  // 表达式
  double && r3 = std::sqrt(2.0); // 函数返回值
  ```

### 2. 移动语义和右值引用

#### 2.1 需要移动语义的原因

- **`常规复制构造函数`**
  - 使用 `const左值引用`作为参数，使得引用关联到`左值实参`。
  - 可执行深复制

- **`移动构造函数`**
  - 使用`右值引用`作为参数，将引用关联到`右值实参`。
  - 只调整记录
  - 在将所有权转移给新对象的过程中，移动构造函数可能修改其实参，意味着`右值引用`参数不应是`const`。

#### 2.2 移动构造函数

[代码示例](./stdmove.cpp)

#### 2.3 赋值

- 适用于构造函数的移动语义考虑也适用于赋值运算符。

### 3. 新的类功能

#### 3.1 特殊的成员函数

- 原有的4个特殊成员函数
  - 默认构造函数
  - 复制构造函数
  - 复制赋值运算符
  - 析构函数
- C++新增的2个
  - 移动构造函数
  - 移动赋值运算符

这些成员函数是编译器在各种情况下自动提供的。

- 如果提供了`析构函数、复制构造函数或者复制赋值运算符`，编译器将`不会自动`提供`移动构造函数`和`移动赋值运算符`。
- 如果提供了`移动构造函数`或`移动赋值运算符`，编译器将`不会自动`提供`复制构造函数`和`复制赋值运算符`。

#### 3.2 默认的方法和禁用的方法

- C++11中如果提供了`移动构造函数`，所以编译器不会自动创建默认的构造函数、复制构造函数和复制赋值构造函数。可使用`关键字 default` `显式声明`方法的默认版本。

  ```cpp
  class Someclass
  {
    public:
      Someclass(Someclass &&);
      Someclass() = default;
      Someclass(const Someclass &) = default;
      Someclass & operator=(const Someclass &) = default;
      ...
  };
  ```

- 关键字 `delete` 可用于禁止编译器使用特定方法。
  - 也可禁止特定的转换

- 关键字 `default`只能用于`6个特殊成员函数`，但`delete`可用于`任何成员函数`。

#### 3.3 委托构造函数

- C++11 允许在一个构造函数的定义中使用另一个构造函数，这种方式称为 **`委托`**。

```cpp
Notes::Notes(int kk,double xx) : Notes(kk,xx,"Uh") {/**/}
```

#### 3.4 继承构造函数

- C++98 使用`名称空间中函数可用`的方式。

- C++11 中使用`派生类`继承`基类`的所有构造函数（默认构造函数、复制构造函数和移动构造函数除外），但不会使用与`派生类构造函数的特征标匹配的构造函数`。

#### 3.5 管理虚方法：`override`和 `final`

- 在C++11中，可使用`虚说明符override`指出要`覆盖`一个函数，将其放在参数列表后面。如果声明与基类方法不匹配，编译器将视为错误。

- `final说明符`：`禁止`派生类`覆盖`特定的虚方法，所以在参数列表后面加上`final`。

- `override`和`final`并`非关键字`，而是具有`特殊含义的标识符`。

### 4. Lambda函数

Lambda 函数，也叫做Lambda表达式。

匿名函数无需给出函数命名。

#### 4.1 比较函数指针、函数符和Lambda函数

在C++11中，对于接受函数指针或者函数符的函数，可使用匿名函数定义作为其参数。

匿名函数与函数的区别：

- 使用 `[]` 替代 `函数名`
- `没有声明返回类型`（返回类型相当于使用decltype根据返回值推断得到）
- 如果`lambda不包含返回语句`，推断出的返回类型将为`void`。

```cpp
[] (int x) {return x % 3 == 0;}
```

当且仅当， lambda表达式完全由一条返回语句组成时，自动类型推断才管用。否则，需要使用新增的返回类型后置语法：

```cpp
[] (double x)-> double{int y = x; return x - y;} // 返回类型为double
```

[匿名函数代码示例](lambda.cpp)

#### 4.2 使用Lambda原因

四个角度来分析

- 距离
  - 函数定义离使用地点近。
- 简洁
  - 函数符代码比函数和lambda代码更繁琐。
- 效率
  - 三种方式的相对效率取决于编译器内联。
- 功能
  - lambda可访问`作用域内`的`任何动态变量`
  - 要捕获使用的变量，可将其名称放在中括号内。
    - 如果`只指定变量名`，如`[z]`，则将`值访问`变量
    - 如果在`名称前加上 &`，如[&count]，则按`引用访问`变量
  - `[&]` 按`引用访问`所有动态变量
  - `[=]` 按`值访问`所有动态变量。

函数指针方法`阻止内联`，因为编译器传统上不会内联其他地址被获取的函数，因为函数地址的概念意味着非内联函数。而`函数符`和`lambda`通常`不会阻止内联`。

可以给lambda指定一个名称，然后使用名称来替代。

```cpp
auto mod3 = [] (int x) {return x % 3 == 0;} // mod3 a name for the lambda

count1 = std::count_if(n1.begin(),n1,end(),mod3);
count2 = std::count_if(n2.begin(),n2.end(),mod3);
```

C++中引入lambda的主要目的：能将类似于函数的表达式用做接受函数指针或函数符的函数的参数。

### 5. 包装器

C++提供多个`包装器`（`wrapper`，也叫做`适配器（adapter）`）。

C++11中提供了其他的包装器：

- `bind`
  - 可替代 `bind1st` 和 `bind2nd`
- `mem_fn`
  - 可将成员函数作为常规函数进行传递
- `reference_wrapper`
  - 能创建行为像引用但可被复制的对象
- `function`
  - 以统一的方式处理多种类似于函数的形式

#### 5.1 包装器function及模板的低效性

模板function 是在头文件functional 中声明，从调用特征标的角度定义了一个对象，可用于包装调用特征相同的函数指针、函数对象或者lambda表达式。

```cpp
// 接受一个char参数和一个int参数，并返回一个double值的任何函数指针、函数对象或者lambda表达式赋值给它
std::function<double>(char, int) > fdci;
```

### 6. 可变参数模板

要创建可变参数模板，需要理解以下要点：

- 模板参数包（parameter pack）
- 函数参数包
- 展开参数包
- 递归

#### 6.1 模板和函数参数包

C++11中提供省略号表示的元运算符（meta-operator）。

- **`模板参数包`**：可以声明表示`模板参数包`的标识符，模板参数包是一个`类型列表`。
- **`函数参数包`**：可以声明表示`函数参数包`的标识符，函数参数包是一个`值列表`。

```cpp
// Args可以与任意数量的类型匹配
template <typename... Args> // Args 是模板参数包
void show_list(Args...args) // args 是函数参数包
{
  ...
}
```

#### 6.2 展开参数包中使用递归

将函数参数包展开，对列表中的第一项进行处理，再将余下的内容传递给递归调用，以此类推，直到列表为空。

```cpp
template <typename T ,typename...Args>
void show_list(T value, Args..args) 
{
  show_list(args...);
}

// 对于按值传递来说，效率低，所以可更改为；
void show_list1(const T& value, const Args&... args)
{
  show_list1(args...);
}
```

### 7. C++11新增的功能

#### 7.1 并行编程

为解决`并行性`的问题，C++定义了一个支持`线程化执行`的内存模型，添加了关键字 `thread_local` ，提供了相关库支持。

关键字 `thread_local` 将变量声明为`静态存储`，其持续性和特定线程相关，即定义变量的`线程过期`时，`变量也过期`。

库支持由`原子操作（automic、operation）库`和`线程支持库`组成。原子操作库提供的头文件：

- `thread`
- `mutex`
- `condition`
- `variable`
- `future`

#### 7.2 新增的库

在C++11中新增专用的头文件库

- random：随机数扩展工具
- chrono：处理时间间隔的途径
- tuple：支持模板tuple。
- ratio：编译阶段的有理数算术库
- regex：正则表达式库。用于指定与文本字符串的内容匹配。

#### 7.3 低级编程

低级编程中的“低级”指的是抽象程度，而不是编程质量。

C++11给低级编程人员提供的两个便利：

- 放松了`POD（Plain Old Data）`的要求。
- 允许`共用体的成员`有`构造函数`和`析构函数`。
