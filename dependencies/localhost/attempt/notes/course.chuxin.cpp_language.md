---
id: khjye3s9bu1xep27usjr338
title: Cpp_language
desc: ''
updated: 1667019409258
created: 1667019409258
---

# c++语法

## Part1：课程介绍

### 1.课程的总体概述

#### 一：为什么要出这门课？

我发现市面上的C++课程基本都停留在C++98阶段，而且基础概念反复重复。
讲的东西对于专业的C++开发不过是入门，还差的很远很远。这就给了很多新手我已经对C++有了基本使用能力的错觉，我已经入门了。

C++可以说是一个大杂烩，它包含c语言面向过程的全部知识，又包括面向对象部分，还包括模板与泛型编程。很多新手在用c++的语法写c，这是非常不正确的，相当于抛弃了面向对象与模板，这些都是C++的精髓。面向对象与模板才是C++的核心，面向过程更多的是对C语言的一个妥协。

要学好这三部分，就要把面向过程，面向对象，模板与泛型编程全部学好。

1. 学好面向过程部分，也就是c语言，需要从编译器的角度出发，每一行代码都要明白内存的变化。
2. 面向对象部分需要在一定程度上理解内存与编译器，但核心已经不再是内存层面了。
3. 模板与泛型不怎么需要了解底层，但也是一个非常复杂的模块。可以说，模板是C++特有的精髓部分，C++几乎所有的库，框架都离不开模板。

很多新手对于C++的理解太过单一，而且学的太浅了。

所以我出了这门课，讲的是企业级别的C++，会有一些难度，但这基本就是现代C++的全部知识点了。应该比市面上几乎所有的教程都全，而且很有深度的。

#### 二：课程内容介绍：企业中，C++11是必学的，后面的会了更好，不会也无所谓

这门课总共包含10个部分和三个附录，大致介绍一下：（重要的课程前面都加了*）

1. Part1: 课程介绍：没什么实际知识点，就是一个介绍
2. Part2:  C++的基本特性，属于C++的基础知识，难以被划分到任意一个模块
3. Part3  类的特性，C++类的全部常用特性应该就这些，比较全了
4. Part4：智能指针，不仅要学习基础知识，使用场景更是核心，很多人根本知道什么时候 该用智能指针。
5. Part5：模板与泛型编程。
(1) 模板很重要，很多人对模板的重视程度不够。
(2) 模板也是泛型编程的基础，泛型编程是一个常用的编程方式，新手对泛型编程可能比较迷糊，觉得不好理解，但它确实功能强大，是C++的核心之一。
6. Part6：stl库：有了泛型编程的基础，就可以学习stl的实现原理。学习stl不仅要学习使 用方法，实现原理更加重要。可以说，对于stl，懂实现原理和只会使用完全是两个阶段。
7. Part7：io库：C++的io功能也很强大，很常用，必会
8. Part8：多线程：现代程序基本都是多线程程序，而C++自带的多线程又是现代C++程序实现多线程的主流方式，所以非常重要。
9. Part9：异常处理：能否合理的处理异常是衡量一个人水平的重要指标，对于大型程序非 常重要。
10. Part10：各种难以归类但很重要的知识点。
11. 附录一：STL全部的算法
12. 附录二：STL标准库提供的仿函数
13. 附录三：STL各种容器的操作

综上所述：13个部分，除了Part1的课程介绍和三个附录几乎全程重点。所以做了个目录，方便随时查看。

#### 三：对新手讲一下我推荐的学习C++的路线

1. C++语法学到差不多，就去学后面的东西，比如后端开发方向，就可以去学linux开发，网络开发，等有了应用场景，C++的语法就很好学了。比如，异常处理的很多语法单讲非常空洞，但放到具体环境中就很好理解了。我将异常处理放到最后也是因为只有有足够多的代码才可以体现出异常处理的意义。

2. 一些理论性的东西建议往后放一放，比如操作系统，网络通信的理论部分。对于想做开发的朋友，推荐先实践，后理论。而数据结构，放到最后，它和开发的关系不怎么紧密，数据结构是体系成型的人用来提高的。

3. C++一大特点就是没有固定的生态，其他语言，比如java都是有自己对应生态的，直接学对应生态即可，导致了C++的以下特点。
(1) C++和底层关系紧密，因为没有固定生态，难以大规模分装，而且C++涉及很多偏向底层的大型项目（比如windows，游戏开发这类特别要求效率的项目），无法牺牲运行效率来换取开发效率。所以C++非常重视计算机网络和操作系统的理论知识。这也导致C++在很多环境下都是不可替代的。
(2) 语言特性繁多，需要兼容各种使用场景，有很大的历史包袱。

#### 四：这门课就不做ppt了

有图片就直接粘贴在文档中。ppt更多的是用来展示的，界面华丽，但信息密度太低了，对于这门课，ppt要做需要500页往上，不论我做起来，还是你们看起来，都费劲。

#### 五：直接开始

其实时间是很宝贵的，工作的人对此体会应该更加深刻。所以我选择直接把文档写出来，而不是边讲边写文档，这样效率更高，节省时间。

### 2.（*）开发环境介绍

使用的开发环境就是vs2019，当然vs2017，vs2022也可以，再早就不推荐了，可能有些功能不支持。
接下来介绍一下vs的基础知识，老手完全可以跳过这一节。

1. vs的介绍：
vs是一个功能极其强大的集成开发环境，说最强也没有问题，主要的缺点就是不能跨平台，只能在windows上运行。
而现在C++的主流开发平台是linux，所以很多人就说vs让开发者缺乏对C++执行过程的了解，linux上没有像vs那样强大的集成开发环境，比较分散，开发人员需要自己调度各种资源。
2. vs的安装与卸载：
(1) vs安装：直接去microsoft官网下载就可以了，傻瓜版，我这里演示一下。注意只安装需要的模块就可以了，如果全安装要上百G。
大致演示一下：
如果没有vs，可以暂停，官网下载一下vs。
(2) （*）vs的卸载：这里特别注意，vs由微软官方推出，是直接关系操作系统内核的，如果乱弄是会玩坏操作系统的，最后就只能重装系统，所以强调一下如何卸载vs。
演示一下：
其实卸载很简单，主要是不要乱弄，其它任何方式都可能会导致各种遗留问题，最后只能重装系统了。
3. vs项目的创建与vs的程序编译过程
(1) vs项目的创建，我用vs2019来演示，C++项目大致分为两种
①控制台项目：程序在黑窗口运行
②windows桌面应用程序：程序有图形窗口
两种程序的区别就是使用的链接库不同，C++默认是不支持图形功能的，要实现图形功能，必须调用系统api，所以两种项目必须有两个链接库。
当然，两种库是可以随时替换的，不一定创建的控制台程序，就一定要当做控制台程序来编写。
我们这门课用的是空项目，能直接体现出C++的语法，没有其它因素的干扰。用的是控制台的链接库。
(2) vs程序的编译过程。很多人说vs的编译过程不利于新人成长，这个说法其实有一定道理，这就和vs的项目目录结构有关了。
①vs的项目目录是一个解决方案下包括多个项目，vs是以文件组成的项目为最小编译单元的。也就是说vs无法单独编译一个项目中的一个cpp文件，会给新手一定的困扰。
这些在老家伙中理所当然，常常被忽略的东西，经常给萌新带来困惑。
4. vs的debug功能简介：
暂时我们只要会断点功能就可以了，需要知道的是，为了支持调试功能，编译和链 接必须添加很多额外的东西，所以使用debug功能，必须以调试的方式进行编译。(正常编译，调试编译需要加许多额外东西)

## Part2：C++的基本特性

### 1.（*）程序的执行过程

程序被执行后就被称为一个进程，一个进程可以被划分为很多区域，这门课我们只需要理解以下的四个区就可以了。

1. 代码区与常量区：进程按照代码区的代码执行，真正的常量也存储在这里，比如“abc”字符串，“1”，“88”等数字。这些是真正的常量。再看一下const关键字。const只不过是让编译器将变量视为常量罢了，和真正的常量有本质上的区别。
2. 栈区：函数的执行所需的空间，注意，当函数执行完毕，函数对应的栈内存全部销毁。
3. 堆区：进程用来灵活分配内存的地方，只有手动释放时才会销毁内存。
4. 静态变量区：用来存储静态变量与全局变量的区域
(1) 静态变量：我们常常需要一些局部作用范围，生命周期却很长的变量
(2) 全局变量：重要性就不必说了，在c语言程序中经常用到，但在C++中不推荐使用，因为会破坏封装性。

具体的存储方式如图所示：

![](/assets/images/2022-10-29-14-00-42.png)

接下来用代码演示一下这几个区域。

堆区和栈区，是程序运行的主要地方。我们用一个最简单的程序来显示栈的用途。

代码演示：

至于堆区，主要意义在于灵活的生命周期，同样是刚才那个例子。
如果需要创建的对象有几十M，每次调用函数都需要创建一个这么大的对象，再复制到对应的容器中，那就太过耗费内存了。而且栈内存非常的小，通常不超过8M。

而使用堆内存，每调用一次函数就可以在堆内存中创建一个对象，容器中只要存储指针就可以了，极大的提高了程序效率。

代码演示：

而静态变量区：
有很多情况下，我们需要作用范围局限在函数之内，但生命周期却很长的变量，比如统计一个函数被调用的次数。

总结：栈区是函数执行的区域，堆区是函数内灵活分配内存的地方，二者缺一不可。
有很多人问为什么不能只在栈上运行程序，因为当函数运行结束时，栈是要销毁的，其上分配的内存全部失效。
也不能只在堆上运行程序，因为堆的唯一寻址方式就是指针，如果没有栈，根本无法使用堆。

提一下：栈区远远小于堆区，一般不超过8M，所以主要的内容都在对堆区上。堆区很大，虚拟内存剩下的都是堆区。

注意：这节课对内存的划分比较粗糙，但新手理解到这里完全没有问题，这门课也够用了。

程序执行的细节，还有剩下的区域是干什么的，我打算出一门叫做C++内存详解的课程，里面会详细讲解。包括pe文件头，内核区等。

### 2.（*）new关键字及内存泄露

1. new关键字是C++用来动态分配内存的主要方式。
代码演示：

new可以直接分配单个变量的内存，也可以分配数组。

在分配单个对象的内存时。
当对象是普通变量时，可以分配对应的内存
当对象是类对象时，会调用构造函数，如果没有对应的构造函数，就会报错。

在分配数组对象内存时：
对于普通变量：可以使用“（）”将所有对象全部初始化为0。
对于类对象，有没有“（）”都一样，均使用默认构造函数，如果没有默认构造函数就会报错。

2. 内存泄露介绍：内存泄露是经常出现的常见bug。
代码演示：

 内存泄露会导致堆内存的逐渐被占用，最终内存用完程序崩溃。常见的情况就是项目测试没问题，上线几天就炸了。然后就会非常麻烦，排查困难，损失很大。
内存泄露是最严重的错误之一，程序不怕报错，就怕一开始运行的好好的，突然就出现了莫名其妙的错误。
这句话也引出了后面的两个部分。
Part4的智能指针可以非常好的避免内存泄露的问题。
Part9的异常处理部分可以恰当的处理程序出现的异常，让程序有错误就立马处理，或直接终止进程，或忽略，不要让异常莫名其妙。这是程序设计的重要理念。(**VLD内存泄漏检测工具**)

### 3. 命名空间

C++经常需要多个团队合作来完成大型项目。多个团队就常常出现起名重复的问题，C++就提供了命名空间来解决这个问题。
比如团队A和团队B都需要定义一个叫做Test的类。
这里用代码简单演示：

顺便提两点：
 命名空间的实现原理，C++最后都要转化为C来执行程序。在namespace A中定义的Test类，其实全名是A::Test。
C++所有特有的库（指c没有的库）,都使用了std的命名空间。比如最常用的iostream。

using关键字设计的目的之一就是为了简化命名空间的。using关键字在命名空间方面主要有两种用法。

1. using 命名空间：：变量名。这样以后使用此变量时只要使用变量名就可以了。举个例子。
2. using namspce 命名空间。这样，每一个变量都会在该命名空间中寻找。举个例子。

（*）所以，头文件中一定不能使用using关键字。会导致命名空间的污染。
还是用刚才的代码演示。

### 4.（*）C++的标准输入输出简介

输入输出简单来说就是数据在输入设备，内存，硬盘，输出设备之间移动的过程。
c语言设定了很多不相关的函数还实现这些过程。
比如printf就是让数据从内存到显示屏（显示屏就是输出设备）。scanf就是让数据从键盘（键盘是输入设备）到内存。此外还有从内存到磁盘的文件操作函数。

c语言的函数虽然简单方便，但彼此之间没有关联。C++有了继承功能，可以让子类与父类之间有关联性，极大的提高各种输入输出功能之间的耦合性。
于是C++用继承功能重写了输入输出功能，这就是io库，io库引入了“流”的概念，数据从一个地方到另一个地方，原本地方的数据就没了，叫做流很贴切。

io库是一个很大的部分，但现阶段我们只要会使用输入输出流，cout和cin就可以了。
cout可以让数据从内存流到输出设备，cin可以让数据从输入设备流到内存。
代码演示：

等到Part7，io库会详细讲解。

### 4.5. const关键字介绍

首先说一下：这一课是后面加的，原先的目录上没有这一课，所以就叫做4.5课了。后面觉得讲一下const关键字还是很有意义的。很多人对const修饰的变量和真正的常量分不清。

const关键字介绍：const是让编译期将变量视为常量，用const修饰的变量和真正的常量有本质的区别。

代码演示：

1. 真正的常量存储在常量区或代码区，比如“abcdefg”这个字符串就存储在常量区，而“3”，“100”这些数字就存储在代码区中，这些都是真正的常量，无法用任何方式修改。

2. const修饰的变量仍然存储在堆区或栈区中，从内存分布的角度讲，和普通变量没有区别。const修饰的变量并非不可更改的，C++本身就提供了mutable关键字（这个关键字在Part3就会讲的）用来修改const修饰的变量，从汇编的角度讲，const修饰的变量也是可以修改的。

### 5.（**） auto关键字的使用

auto是C++11新加入的关键字，就是为了简化一些写法。
代码演示：

使用auto推断类型确实简单方便，但有个基本要求，就是在使用auto时清楚的知道编译器会给auto推断出什么类型。
为了学习auto的类型推断，我使用一个boost库来确定变量的具体类型。至于boost是什么，这里就不介绍了，大家可以去百度一下。
boost库的类型推断更加灵活方便，直观。而且Part10讲万能引用，完美转发时boost也是必须使用的，所以这里就提前使用boost了。其实这里采用vs默认提供的类型提示功能也可以。

首先下载，安装boost库，就直接视频演示了，不在文档中描述了。

这两个命令执行完毕，boost库也就编译好了。boost库很大，可以选择编译自己想要的模块，我就直接全部编译了。boost是很复杂的，不是几句话能说清楚，要深入理解可以去官网学习。
两个库，每一个编译都需要十几分钟，所以视频就暂停了。

这两个命令我放在一个boostCommand.txt的文件中，这个文件已经放在最终的文件包中。

auto有几个点需要注意：
有些不好理解，可以多看几遍，或者带着问题学习下面的课程，Part2的所有知识都是反复用到的。

1. auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。

代码演示：

2. auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。

代码演示：

3. auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。可能有些不好理解，看看代码就好说了。3和4的主要作用对象就是指针。

代码演示：

4. auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留。

代码演示：

其实3，4为什么会出现这种情况，因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。

确实不太好理解，尤其是基础不扎实的人。不懂了可以多问问我。

5. 当然，我们可以在前面加上const，这样永远都有const的含义。

代码演示：

6. auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a = b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。
7. （*）最重要的一点，就是auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。
8. （*）auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。

注意：auto的用法这里大致了解就可以了，Part10会有一节详细的讲auto的类型推断的，这节课是没有涉及右值引用的，那里会将这一部分。而且现在没有讲模板，难以讲出auto关键字的主要用法。

```cpp {.line-numbers, highlight=[5, 8, 10, 12]}
#include <iostream>

int main(){
  int num = 10;
  auto var = num; // 推断类型：int
  
  const int num_ = 20;
  auto var_ = num_ //        int 因为进行值传递，不会改变原值，有两份内存空间

  const auto var_1 = num_    // const int 

  auto& var_2 = num_      // int const&    因为相当于起别名，所以需加const保证原内存值不能被改
}

```

```cpp {.line-numbers, highlight=[7]}
#include <iostream>
#include <boost/type_identify>

int main(){
  int i = 20;
  auto i2 = i;
  type_identify<decltype(i2)>().pretty_name().... // boost库中的类型推断
}
