---
id: bv12hhpa22dulj056d8tjnf
title: C_assembly
desc: ''
updated: 1666223032719
created: 1666181326775
---
# c语言对应的32位汇编

## 第一课：课程介绍

### 课程目的

1. 首先说一下这套课程的目的，在我的理解中，C++最好要从底层学，要求基础绝对扎实。这样才可以真正发挥出C++粒度细，效率高的优势，所以我打算出一套完整的课程。包括c语言对应的汇编，c++的内存分析（也就是c是如何转化为C++的），网络模型等，从底层一直到应用的完整课程。

### 汇编的意义

1. 懂汇编对于理解c语言非常重要，汇编之下，了无秘密，可以说不懂汇编，永远不可能成为c语言高手。因为c语言和汇编直接对应。懂了汇编，会觉得c语言的语法就是理所当然的了，不再需要去死记硬背。而且可以真正理解什么是堆栈，什么是指针，实际上指针和其它变量无本质区别，懂了汇编一目了然。
2. 汇编对于调试也非常有帮助，真正理解堆栈，内存变化可以说是调试的关键。
3. 汇编对于以后学习C++也非常有帮助，比如智能指针和右值引用，我想过很多方法，结果就是只有理解汇编才可以真正理解智能指针，右值引用。不懂原理，死记硬背，难以变通。懂了原理，一目了然。
4. 汇编也可以让我们真正了解编译，链接的过程，而不是只知道这两个名词，却不知道实际过程。

### 难度介绍

有人要问，汇编是不是很难啊？这里我要说，不是。
可以说汇编是最简单的语言了，因为我们只需要学习C语言对应的汇编即可，不需要真正去写代码。语法就那么几个，非常有章法，非常有规律，我们这门课也不需要去扩展。

### 环境介绍

我们用的开发环境主要就是vs（vs2013，vs2015，vs2017，vs2019，vs2022都可以）和ollydbg，gdb偶尔也会用。Ollydbg的官网为www.ollydbg.org。在vs中查看反汇编，用来学习c语言对应的汇编。严格来说，vs中存在大量的伪汇编，而且无法修改汇编代码，无法轻易查看堆栈变化，所以我们用ollydbg来学习汇编语法。当然，一少部分汇编语法linux平台下和windows平台下差别较大，也会用gbd进行演示。

不会讲太多没用的话，干净利索。很多工作的人可能深有体会，时间是最宝贵的。很多课程都是几十，上百个小时，但其实根本没有时间看。
好！直接开始。

## Part1：函数调用过程----第二课  进制

c语言程序的本质就是操作系统调用了main函数，所以首先我们要做的就是明白c语言中函数调用的过程，也就是这个：

当然要完全理解函数的调用过程，我们首先应该学一些基础知识，首先就是进制：计算机用的是二进制，不同于我们日常用的十进制，理解进制转化，更可以理解计算机的数据变化过程。

不同的进制也就是对同一个数的不同表示方法。

进制的定义：N进制，逢N进一：
比如16进制：0，1，2，3 ... F，逢16进1.
比如2进制：0，1，逢2进1.
比如10进制：0，1 ... 9 逢10进1

首先要学的是进制之间的转化。实际工作用的都是计算器。
至于具体的计算方法，也很简单。比如
一个N进制数xyz转化为10进制数。
只要x *N^2 + y* N^1 + z就可以了。
至于10进制到N进制。就是这个过程的逆过程，不需要掌握，只要会用计算器就可以了。

然后就是N进制的加减乘除，也是计算器即可。乘除如果硬要笔算，需要转化为10进制，因为我们没有N进制的乘法表。

说了这么多，其实就是一条，对于进制问题我们以后用的都是计算器。

## 第三课：存储设备

一台机器要被称为计算机，最少也要有两部分，存储模块和计算模块。现代计算机的计算模块我们这门课不需要掌握，但是存储模块却一直伴随着汇编语言的始末。

首先我们来看一张图，我自己画的，简陋了一点。首先解释一下这张图，计算机的存储设备可以按照存储容量的从大到小，速度从慢到快，单位存储价格从低到高分为网络（可以认为存储数量无限），磁盘，内存，缓存，寄存器。其中寄存器在cpu内部，其它的都在cpu外部。

1. Cpu只能直接使用寄存器中的数据，任何数据都必须要传递到寄存器中才可以使用。
2. 缓存设备计算机早期是不存在的，后来为了加快内存与寄存器的交换数据的速度而添加，
这门课不需要理解。
3. 内存
(1) 程序的主要过程都在内存上体现。这里讲一下物理内存和虚拟内存的概念，物理内存就是我们使用的内存条，但是用户在开发程序时是以进程为单位的，如果直接使用物理内存会非常困难，所以发明了虚拟内存的概念。在32位的系统中，每个进程都会有一个4g的虚拟内存，我们直接操作4g的虚拟内存，然后cpu的MMU模块会将虚拟内存映射到物理内存上。
(2) 内存上的内容在系统关闭时会清空，只有写到磁盘上才可以长久存储
4. 磁盘：磁盘是计算机长期存储的主要设备，比如文件就写在磁盘上。
5. 网络不必说，需要数据时从网络获取就可以了。

## 第四课：标准类型的存储方式

c语言是编译型语言，编译型语言首先将源代码编译生成机器语言，再由机器运行机器码，程序在运行时会逐步运行代码区的代码。所以c语言的每个变量都必须有数据宽度，否则无法进行堆栈操作，这个过程以后会进行详解。

计算机中常见的数据宽度：
位：（英文是bit），可以存储一个0或1
Char，8位，8个0或1，可以存储的数据也就是0 —— 0xFF（0x写在最前面代表这是16进制的数）
Short，16位，16个0或1，可以存储的数据也就是0 —— 0xFFFF
Int, 32位，32个0或1，可以存储的数据也就是 0 —— 0xFFFFFFFF
Long，32位系统中32位，windows中哪怕64位系统也是32位，linux的64位系统中为64位

那么是不是我们有了一串数据我们就可以确定它的大小了呢，不是。一串数据的大小究竟是多少，还在于我们如何去看待他。

比如说short和unsigned short都是16位。怎么表示范围就不同了呢。
这就涉及另一个问题了。

编码方式，这里要讲三种编码方式
原码：
反码：
补码：

1. 原码
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:
[+1]原 = 0000 0001
[-1]原 = 1000 0001
第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:
[1111 1111 , 0111 1111]
即
[-127 , 127]
原码是人脑最容易理解和计算的表示方式.
2. 反码
反码的表示方法是:
正数的反码是其本身
负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.
[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反
可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.
3. 补码
补码的表示方法是:
正数的补码就是其本身
负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补
对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码再计算其数值.
正数原码储存，负数补码储存、

## 第五课：寄存器和内存

这门课我们用到的主要就是寄存器和内存。
寄存器：在32位系统中，有8个通用寄存器，1个指令寄存器EIP，一个标志寄存器EFL。

这里额外说一点，如何判断一个系统是多少位，寄存器和总线是多少位系统就是多少位，
总线和寄存器的位数必须相等。所以32位系统，寄存器就是32位。

那很多人就有疑问了，我们现在都是64位机，为什么要学32位汇编呢。
一： 64位和32位无本质区别，指令是类似的
二： 现在很多程序都是32位，比如vs，默认就是32位程序

首先我们要讲8个通用寄存器，分别是
EAX，EBX，ECX，EDX
ESP，EBP，ESI，EDI
这8个寄存器，暂时当做名词记住，不需要理解。
对于EAX，EBX，ECX，EDX这四个寄存器，我们常常使用它们的16位和8位部分。
其余3个也是同理，比如ebx也包括bx，bl，bh。

然后讲一下内存，32位系统中，虚拟内存为4g个字节。这也是32位系统中指针为4个字节的原因，这样恰好就可以寻址到4g虚拟内存的全部地址。

再讲一下，大端序和小端序的概念。做过网路开发的人都知道，网络传输中必须使用网络字节序，这个网络字节序就是大端序。
小端序简单来说就是高位高地址，低位低地址。大端序正好相反。

## 第六课：基础指令（一：mov指令和内存地址）

Mov指令，mov指令绝对是所有指令中使用频率最高的，没有之一。Mov指令就是移动的意思，有五个用途：
(1)一个立即数（也即是普通的数）到寄存器
(2)寄存器到寄存器
(3)立即数到内存
(4)寄存器到内存
(5)内存到寄存器
特别注释：不能内存到内存

DWORD PTR代表4个字节
WORD PTR 代表2个字节
BYTE PTR 代表1个字节

内存地址的五种形式（通过偏移量查找内存，如：mov dword ptr ds[eax+ebx], 2000）

1. 形式一：立即数
2. 形式二：八个通用寄存器中的任意一个
3. 寄存器 + 立即数
4. Reg + reg *｛1， 2， 4， 8｝（很多人会想，这不就是数组吗，对的这就是数组）
5. Reg + reg* ｛1， 2， 4， 8｝ + 立即数。

## 第七课：基础指令（二：push，pop，jmp，call，ret）

在讲push指令之前，我们讲一下什么是栈，栈就是程序在执行时已经通过mmu在物理内存上映射的一段虚拟内存，所以栈内存从汇编的角度都是可以直接修改的。栈内存不大，32位系统一般不会超过4M，所以程序不要在栈内存上分配太多内容。

1. Push指令，格式：push + 立即数/内存/寄存器
(1)向栈压入数据，8个通用寄存器虽然叫通用寄存器，但是在某些方面还是有特定功能的，比如esp寄存器，存储的就是栈顶指针的值，所以第二个功能就很明显了。
(2)修改esp的值

2. Pop指令，格式：pop + 内存/寄存器
(1)将栈顶指针对应的值复制到指定的内存/寄存器中
(2)修改esp的值

总结：push和pop正好相对，push是压栈，pop是出栈

3. Jmp指令，格式：jmp + 立即数/寄存器/内存
(1)设置eip的值，也就是修改程序即将执行的代码。Mov指令不能修改eip的值，但jmp可以。当然，只能将jmp修改到代码区。

4. Call指令，格式：call + 立即数/寄存器/内存
指令介绍：c语言的函数本质即使跳转到另一片代码，执行完毕再返回。Jmp 似乎可以很好的完成工作，但是jmp的缺点是去了，不知道怎么回来。所以我们需要将调用jmp的的代码的下一行代码的地址存储起来，方便返回，这个存储方法就是压栈。

(1)设置eip的值
(2)将调用jmp的下一行代码的地址压入栈中

5. Ret指令，格式：就是ret，什么也不加
(1)将栈顶指针对应的值存放到eip中
(2)Esp加4

总结：call指令和ret指令就是c语言调用函数，并且返回的指令。是非常明确的指令，在做破解时，看到call和ret，真的会有一种柳暗花明又一村的感觉。不过大多数的程序都会对call和ret进行改写，以增加破解难度

## 第八课：汇编基础指令（三：add，sub，lea，stos，rep指令）

1. add指令，格式： add 寄存器/内存  立即数/寄存器/内存
(1) 将后面的数加入到前面的寄存器或内存中
2. Sub指令，格式： sub 寄存器/内存   立即数/寄存器/内存
(1) 就是前面的数减去后面的数，然后再存放在前面的寄存器或内存中
3. Lea指令，格式：lea 寄存器 内存
(1) 将内存的偏移地址存放到寄存器中。注意：是偏移地址，一定要将lea和mov指令区分开，mov指令取的是内存对应的值
举个例子
假设esi = 0x1000，DWORD PTR ds:[0x1000] = 0x2000.
则：
lea ebx, dword ptr ds:[esi]后，ebx为0x1000  // 取的是内存偏移值
Mov ebx, dword ptr ds:[esi]后，ebx为0x2000
4. Stos指令，格式：就是stos
(1) 将eax的数据复制到edi所指的地址中
(2) Edi增加4个字节
Stos类似的指令还有stosw（取两个字节），stosb（取一个字节），分别是将ax，al的值复制到edi对应的内存中 // stos ES:[edi];

5. rep指令，格式：rep + 任何指令
(1)Rep后面的指令每执行一次，ecx的值就会减一，当ecx的值为0时，后面的指令不再重复执行。所以在使用rep指令之前都会给ecx寄存器赋值。

## 第九课：函数的返回值与参数传递

使用call和ret的指令，已经可以跳转到一处执行代码，然后在返回了。在实际代码中观察一下。但是，函数返回值和函数参数的问题并没有解决。
返回值的问题简单，我们规定，用eax来存放返回值。

但是参数传递的方法就比较繁琐了，如果也用寄存器来传递参数，那寄存器数量根本不够用啊，所以我们用内存来传递参数，具体一点说就是栈。
这一方法也被称为ebp寻址

![](/assets/images/2022-10-28-21-34-37.png)

![](/assets/images/2022-10-28-21-40-10.png)

![](/assets/images/2022-10-28-21-55-14.png)

![](/assets/images/2022-10-28-21-57-57.png)

![](/assets/images/2022-10-28-22-03-38.png)

```cpp
#include <stdio.h>
int test(int a, int b){
  return a + b;
}
int main(){
  int a = 1;
  int b = 2;
  test(a, b);
  return 0;
}
```

## Part2：C语言各种语法，变量对应的汇编---第10课：函数内的整形变量与const常量的存储方式

首先，我们在函数中随便添加一个变量，查看一下汇编的变化情况。
在vs的debug模式下，每个变量除了自己占用的字节位数，前后都会有4个字节用来存储调试信息。所以我们可以看到4字节的int占了12个字节的存储空间。
各种变量的寻址方式也非常简单，ebp - 8就是第一个变量。
// 局部变量：const int a = 20; 对于c语言来说，在栈中跟普通变量存储一样

## 第11课：c语言数组和结构体对应的汇编

c语言的数组和结构体其实非常简单，就是将多个数据放到一起，遵循和其它变量一样的寻址方式。
在debug模式下，数组，结构体的前面和后面都有4个字节用来存放调试信息。

![](/assets/images/2022-10-28-22-36-54.png)

## 第12课：指针，数组的本质（重点，指针本质和其它变量没有区别）

1. 指针的普通用法
2. 指针的函数传递
（1）举个最简单的例子，我们在写交换函数时，为什么用指针传递才可以改变对象的值，这就是原因。
3. 数组的本质：数组名其实就是个指针，比如int iArr[5]这个数组，这个iArr就是一个指向数组第一个元素的指针。（就是int* const iArr）
4. 多维数组也是同理，比如二维数组，二维数组在内存上和一维数组完全一样，
所谓的多维不过是给用户看的

![](/assets/images/2022-10-28-22-47-56.png)

![](/assets/images/2022-10-28-22-54-08.png)

## 第13课：EFL寄存器与jcc指令集

8个通用寄存器，ESP，EFL一共10个寄存器中，只有EFL这个寄存器没有讲了。这个寄存器其实很重要。c语言里面的控制语句，比如if，for，while都要用jcc指令集才能实现，使用jcc指令集又需要学会EFL寄存器。
这门课我们只要学习几个标志位就可以了。

![](/assets/images/2022-10-29-07-05-01.png)

这么多标志位，我们并不需要全部掌握，只需要掌握我接下来列出的几个就可以了。再说一点，只有运算操作才影响标志寄存器，比如加减乘除，左移，右移。Mov指令这类不涉及运算的指令是不会影响标志寄存器的。

1. CF位（carry flag）：判断无符号整数是否有溢出状态，若一个计算使数的最高有效位发生借位或错位，则置1，反之则置0.
2. ZF位（zero flag）：若计算结果为0，则置1，否则置0。这个位常常与以下几个指令一起使用。
(1) CMP指令：CMP指令和sub指令唯一的区别就是不会改变前面内存或寄存器的值。只要观察ZF位是否为1就可以判断两个比较的数是否相等。
(2) TEST指令：TEST指令和AND指令唯一的区别就是不会改变前面的寄存器或内存，TEST EAX，EAX，可以简单的判断EAX的值是否为0
3. SF位（sign flag）：表示有符号整型的最高有效位，0为正，1为负。
4. OF位（overflow flag）：有符号数是否溢出，溢出则置1，否则置0。对于 一个数。
(1) 如果将它视为有符号数，看OF位。
(2) 视为无符号数，看CF位

学会了这些标志位：jcc指令集就已经学会了绝大部分

Jcc指令集合（不需要背，用的多了就记住了）。jcc指令集和jmp的区别就是有了条件才会跳转。

1. JE（JZ）：ZF = 1时则跳转，也就是运算结果为0则跳转
2. JNE（JNZ）：ZF = 0时则跳转，也就是运算结果不为0则跳转

3. JS ：SF = 1时则跳转，也就是有符号数结果为负则跳转
4. JNS：SF = 0时则跳转，也就是有符号数结果不为负则跳转

5. JO：0F = 1时则跳转，也就是有符号数溢出则跳转
6. JNO：OF = 0时则跳转，也就是有符号数未溢出

7. JA（JNBE）：CF = 0 且 ZF = 0时则跳转，也就是无符号数大于则跳转
8. JB（JNAE）：CF = 1 也就是无符号数小于则跳转
9. JNB（JAE）：CF = 0则跳转，也就是无符号数大于等于则跳转
10. JNA（JBE）：CF = 1或ZF = 1，也就是无符号数小于等于则跳转

11. JL（JNGE）：SF ！= OF ，也就是有符号数小于则跳转
12. JNL（JGE）：SF = OF，也就是有符号数大于等于则跳转
13. JLE（JNG）：ZF = 1 或 SF ！= OF，也就是有符号数小于等于则跳转
14. JNLE（JG）：ZF = 0 且 SF = OF，也就是有符号数大于则跳转

## 第14课：c语言的条件控制语句（if，switch，for，while）

c语言的条件控制语句其实就两种：分支语句，循环语句

1. 分支语句：if
2. 分支语句：switch
3. 循环语句：for
4. 循环语句：while

```c
#include <stdio.h>

int main(){
  int a = 1;
  int b = 2;
  if(a > b){
    printf("a > b ");
  }else{
    printf("a < b");
  }
}
```

![](/assets/images/2022-10-29-07-20-10.png)

![](/assets/images/2022-10-29-07-24-20.png)

![](/assets/images/2022-10-29-07-26-55.png)

![](/assets/images/2022-10-29-07-31-24.png)

## Part3：C语言的编译过程----第15课：虚拟内存的区域划分（堆，栈，代码，动态库等）

我们都知道c语言到可执行程序包括预处理，编译，汇编，链接4个部分，在最终生成的可执行程序中，包含以下模块

![](/assets/images/2022-10-29-07-43-57.png)

严格的来说这张图并不准确，比如一个虚拟内存最前面应该是null指针区。Stack结束后是64k的禁入区，用来隔离用户区和内核区。
我们需要明白的只有以下几个。

1. 数据区在程序编译时就会分配好虚拟内存地址。数据区包括ro数据区（也就是只读数据区），rw数据区（读写数据区）。
(1) ro数据区又可以划分为
①.text，代码区，程序执行的代码就存储在这里。
②.rodata，只读数据区，真正的常量，比如字符串常量，浮点数
(2) rw数据区可以分为
①.bss 用来存放未初始化的全局变量，静态变量。
②.data 用来存放已经初始化的全局变量，静态变量，const全局变量，注意：const全局变量也是存放在这里，const是一种伪常量，是给编译期看的。

2. 堆区和栈区是程序执行的主要地方
3. 共享库加载区是程序存放动态库的地方，比如我们常用的stdio.h的实现部分就被封装在 一个动态库中

## 第16课：预处理过程

对源程序的伪指令（即以#开头的指令）和特殊符号进行处理的过程。

1. 伪指令包括：
(1)宏定义指令
(2)条件编译指令
(3)头文件包含指令
2. 特殊指令：
(1)__FILE__ 进行编译的文件名称
(2)__LINE__ 文件的行号
(3)__DATA__ 文件的日期
(4)__TIME__ 文件被编译的日期

![](/assets/images/2022-10-29-07-50-27.png)

## 第17课：编译过程

对于计算机科班的同学，应该都学过编译原理，那对以下的4个阶段应该很熟悉，这四个步骤这里也无法详细展开，大致介绍一下，有个概念就可以了。

1. 词法分析
(1) 左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词，对识别出的单词给出定性、定长的处理。
(2) 这一步只简单的判断单词的长度，是否是关键字。
2. 语法分析
(1) 语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如"程序"，"语句"，"表达式"等等，语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。
(2) 在这一阶段，可以对各种单词进行组合了，但不会根据前后文判断是否出错。举个简单的例子。
对于以下代码
const char*ptr = “abcdefg”;
void add(int a) { ++a; }
这一阶段已经可以将const char* ptr = “abcdefg”，以及void add(int a) { ++a; }识别为两行代码了，但是无法判断函数类型出现错误。因为这一阶段无法根据前后文判断是否出错，也就是不会去判断a的类型，所以没有错误

3. 语义分析
(1) 语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。比如语义分析的一个工作是进行类型审查，审查每个算符是否具有语言规范允许的运算对象，当不符合语言规范时，编译程序应报告错误。
(2) 语义分析之后，编译过程就不再应该出现错误
(3) 还是刚才的代码，这个阶段会根据前后文检查数据类型，也就是可以根据前后问判断数据类型了，所以会报错。
4. 优化后生成相应的汇编代码
(1) 这一步没什么好说的，就是生成对应的汇编代码

## 第18课：链接过程

对于链接过程，首先我们要明白，c语言是每个源文件都是单独编译的，由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。
例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。

链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。

根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：

1. 静态链接：在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。

2. 动态链接：在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。

对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。
